/*********************************************************************************                               Magic Pixel*                  5F, No.3, Creation Road III, Science_Based*                   Industrial Park, Hsinchu, Taiwan, R.O.C*               (c) Copyright 2004, Magic Pixel Inc, Hsinchu, Taiwan** All rights reserved. Magic Pixel's source code is an unpublished work and the* use of a copyright notice does not imply otherwise. This source code contains* confidential, trad secret material. Any attempt or participation in* deciphering, decoding, reverse engineering or in ay way altering the source* code is strictly prohibited, unless the prior written consent of Magic* Pixel is obtained.** Filename      : soft_amr_enc.c* Programmer(s) : C.W* Created       : 2009/07/28* Descriptions  :********************************************************************************/#include "global612.h"#include "mptrace.h"#include "debug.h"#include "typedef_amr.h"// AMR encoder only accept special source stream -// 		One channel, 16bits, 8k sample rate pcm dat !!!!!!!!!!!!!!!!!!!!!!#if AMR_ENCODE_ENABLE#define MR515  1#define AMR_MAGIC_NUMBER "#!AMR\n"#define L_FRAME 160SBYTE amrFileEncode(ST_SEARCH_INFO *pSearchInfo){	STREAM *sHandle;	DriveHandleCopy(DriveGet(MAX_DRIVE_NUM), DriveGet(DriveCurIdGet()));	sHandle = FileListOpen(DriveGet(MAX_DRIVE_NUM), pSearchInfo);	if (sHandle == NULL)		return -1;	{		BYTE pri_name[9];		memset(pri_name, 0, 9);		memcpy(pri_name, pSearchInfo->bName, 8);		mpDebugPrint("--- Start to encoding audio file %s ---", pri_name);	}	mpDebugPrint("sHandle = %x", sHandle);	/*-----------------------------------------------------------------------*	 * Initialisation of the codec.                                          *	 *-----------------------------------------------------------------------*/	int allow_dtx = 0;	MagicPixel_AMRCODEC_SRAM_Init((char *)0xb8000000, 0x6000);	if (MagicPixel_AMRENC_Init(allow_dtx)){		mpDebugPrint("amr Shit!!!");		return -1;	}	// --------------------------------------------------------------------------//	// Prepare output AMR file section                                           //	// --------------------------------------------------------------------------//	int ret;	STREAM *amrHandle;	DRIVE *sDrv = DriveGet(SD_MMC);	ret = CreateFile(sDrv, "testing", "amr");        // fixed file name temporarily	if (ret){		UartOutText("create file fail\r\n");		return -1;	}		amrHandle = FileOpen(sDrv);	if(!amrHandle){		UartOutText("open file fail\r\n");		return -1;	}	/* write magic number to indicate single channel AMR file storage format */	FileWrite(amrHandle, AMR_MAGIC_NUMBER, strlen(AMR_MAGIC_NUMBER));	// --------------------------------------------------------------------------//	// Decode section                                                            //	// --------------------------------------------------------------------------//	WORD new_speech[L_FRAME];	WORD serial[1024];  //This buffer is for verify only	BYTE packed_bits[512];	WORD retSize;	BYTE fend = 0;	DWORD posA, posB;	int a = 0;	if(!strcmp(pSearchInfo->bExt, "wav")){		mpDebugPrint("skip wav header...");		Seek(sHandle, 44);	//Skip WAV header	}	{		BYTE pri_name[9];		memset(pri_name, 0, 9);		memcpy(pri_name, pSearchInfo->bName, 8);		mpDebugPrint("Amr encoding...%s.%s", pri_name, pSearchInfo->bExt);	}	while(fend == 0)	{		int i, iSize;		BYTE *tmp;		posA = FilePosGet(sHandle);		retSize = FileRead (sHandle, new_speech, L_FRAME << 1);		posB = FilePosGet(sHandle);		//mpDebugPrint("------------------------------------------------------");		//for(i = 0; i<L_FRAME; i++)		//	mpDebugPrint("%d. 0newSpeech: %x", i, new_speech[i]);		//Change endian 		for (i = 0; i < L_FRAME; i++){			tmp = (unsigned char *)(new_speech + i);			new_speech[i] = (short)(tmp[0] + (tmp[1] << 8));		}		//for(i = 0; i<L_FRAME; i++)		//	mpDebugPrint("%d. 1newSpeech: %x", i, new_speech[i]);		iSize = MagicPixel_AMRENC_Encode(MR515, serial, new_speech, packed_bits);		//for(i = 0; i<iSize; i++)		//	mpDebugPrint("%d. %x",  i, packed_bits[i]);		//		mpDebugPrint("AMR packet size : %d, File read size : %d, Handle position: %d",		//			iSize, retSize, FilePosGet(sHandle));		//mpDebugPrint("------------------------------------------------------");		mpDebugPrint("Curpos: %d", FilePosGet(sHandle));		FileWrite(amrHandle, packed_bits, iSize);		//if(posA > posB || retSize != (L_FRAME << 1) || a == 5000)		if(posA > posB)			fend = 1;		a++;	}	FileClose(amrHandle);	FileClose(sHandle);	return 1;}struct amrCache{	WORD buf[L_FRAME];	WORD size;			// Unit : WORD(2 bytes)};static struct amrCache enAmrCache;void enAmrCacheReset(){	enAmrCache.size = 0;	memset(enAmrCache.buf, 0, L_FRAME << 1);}DWORD amrChunkEncode(WORD *inBuf, unsigned char *outBuf, DWORD iSize, STREAM *amrHandle){	DWORD totalSize = 0;	DWORD outSize = 0;	WORD serial[1024];  //This buffer is for verify only	WORD amrInbuf[L_FRAME];	while(iSize >= (L_FRAME << 1)){		int i = 0;		BYTE *tmp;		//Change endian 		for(i = 0; i < enAmrCache.size; i++){			UartOutText("m");			tmp = (unsigned char*)(enAmrCache.buf + i);			amrInbuf[i] = (short)(tmp[0] + (tmp[1] << 8));		}		for (; i < L_FRAME; i++){			tmp = (unsigned char *)(inBuf + i);			amrInbuf[i] = (short)(tmp[0] + (tmp[1] << 8));		}		outSize = MagicPixel_AMRENC_Encode(MR515, serial, amrInbuf, outBuf);		iSize  -= (L_FRAME<<1);		inBuf  += (L_FRAME - enAmrCache.size);		outBuf += (outSize);		totalSize += outSize;		enAmrCache.size = 0;			}	if(iSize){		memcpy(enAmrCache.buf, inBuf, iSize);		enAmrCache.size = iSize >> 1;		iSize = 0;	}	mpDebugPrint("inSize: %d, totalSize: %d", iSize, totalSize);	return totalSize;}// This initial function is used for amrChunkEncode caseint MagicPixel_AMRENC_Init_All(){	int ret = 0;	int allow_dtx = 0;	MagicPixel_AMRCODEC_SRAM_Init((char *)0xb8000000, 0x6000);  // Init amr encoder sram setting	if (MagicPixel_AMRENC_Init(allow_dtx)){                     // Init amr encoder		mpDebugPrint("amr Shit!!!");		ret = -1;	}	enAmrCacheReset();                                          // Init amr cache buffer	return ret;}#endif