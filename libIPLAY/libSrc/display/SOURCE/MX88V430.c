
#include "global612.h"
#include "mpTrace.h"

#if (TCON_ID == TCON_MX88V430)
#define CLK_LO          0xfffffffe
#define CLK_HIGH        0x00000001
#define DATA_LO         0xfffffffd
#define DATA_HIGH   0x00000002
#define IIC_ID          0x28
#define IIC_DELAY   10
#define IIC_NO_ACK      1
#define IIC_ACK             2
#define START               3
#define STOP                4
#define IGNORE              5

void enterData(DWORD val){
    register GPIO *sGpio;
    sGpio = (GPIO *) (GPIO_BASE);

    if((val == CLK_LO) || (val == DATA_LO))
        sGpio->Gpdat0 &= val;
    else
        sGpio->Gpdat0 |= val;
    IODelay(IIC_DELAY);
}

BYTE IIC_SetValue(BYTE data1, BYTE condition){
    register GPIO *sGpio;
    BYTE mask;
    
    sGpio = (GPIO *) (GPIO_BASE);
    sGpio->Gpcfg0 &= 0xfffcfffc;  //1111 1111 1111 1100, default function
    sGpio->Gpdat0 |= 0x00030000;  // GP0, GP1 output

    if(condition == START){
        enterData(CLK_HIGH);
        enterData(DATA_HIGH);
        enterData(DATA_LO);
        enterData(CLK_LO);
    }
    mask = 0x80;
    while(mask > 0){
        if((mask & data1) == mask){
            enterData(DATA_HIGH);
        } else {
            enterData(DATA_LO);
        }

        enterData(CLK_HIGH);            
        enterData(CLK_LO);
        mask >>= 1;
    }
    
    //enterData(DATA_HIGH);
    sGpio->Gpdat0 &= 0xfffdffff;  // data = input direction
    enterData(CLK_HIGH);

    if(sGpio->Gpdat0 & 0x00000002){
        //UartOutText("n");
        //__asm("break 100");
        //return IIC_NO_ACK;
    }else {
        //UartOutText("A");
        sGpio->Gpdat0 |= 0x00030000;  // GP0, GP1 output
    }
        
    enterData(CLK_LO);    

    if(condition == STOP){
        enterData(CLK_HIGH); 
        enterData(DATA_HIGH);
    }

    return IIC_ACK;
}

BYTE IIC_GetValue(){
    register GPIO *sGpio;
    BYTE data, i;
    
    sGpio = (GPIO *) (GPIO_BASE);
    sGpio->Gpcfg0 &= 0xfffcfffc;  //1111 1111 1111 1100, default function
    sGpio->Gpdat0 &= 0xfffdffff;  // GP1 = input
    sGpio->Gpdat0 |= 0x00010000;  // GP0 = output


    data = 0;
    for(i = 0; i < 8; i++){
        data <<= 1;        
        enterData(CLK_LO);
        enterData(CLK_HIGH);
        data |= ((sGpio->Gpdat0 & 0x00000002) >> 1);
    }

    // ACK
    enterData(CLK_LO);
    sGpio->Gpdat0 |= 0x00030000;  // GP0, GP1 output
    enterData(DATA_LO); // ACK    
    enterData(CLK_HIGH);
    sGpio->Gpdat0 &= 0xfffdffff;  // GP1 = input
    
    // end
    enterData(CLK_LO);
    enterData(CLK_HIGH);
    enterData(DATA_HIGH);
    
    return data;
}

/*
1.       Reg:0x11 / Value:0xf4 ¡V Modify the D2 (Sharpness effect enable).

2.       Reg:0x24 / Value:0x18 ¡V Edge filter coefficient A.

3.       Reg:0x25 / Value:0x18 ¡V Edge filter coefficient B

4.       Reg:0x26 / Value:0x18 ¡V Edge filter coefficient C.

*/

// index, value, index, value .....
DWORD RegValue;

//For 7"    panel 0x8A, 0x57
//For 5.6" panel 0x8A, 0x3A
BYTE v43reg[]={ 
0x00,0x9D,0x01,0x07,0x02,0x03,0x03,0x65,0x04,0x06,0x05,0x06,0x06,0xE7,0x07,0x69,0x08,0x00,0x09,0x10,0x0A,0x00,0x0B,0x08,0x0C,0x08,0x0D,0x08,0x0E,0x08,0x0F,0x08,
0x10,0x80,0x11,0xF4,0x12,0x90,0x13,0x90,0x14,0x90,0x15,0x75,0x16,0x75,0x17,0x75,0x18,0x80,0x19,0x00,0x1A,0xE0,0x1B,0x4E,0x1C,0x00,0x1D,0x00,0x1E,0x00,0x1F,0x00,
0x20,0x40,0x21,0xFF,0x22,0x00,0x23,0x00,0x24,0x18,0x25,0x18,0x26,0x18,0x27,0x00,0x28,0x00,0x29,0x00,0x2A,0x00,0x2B,0x00,0x2C,0x00,0x2D,0x00,0x0E,0x00,0x2F,0x00,
0x30,0x20,0x31,0x63,0x32,0x00,0x33,0x15,0x34,0x00,0x35,0x47,0x36,0x00,0x37,0x04,0x38,0x00,0x39,0x09,0x3A,0x00,0x3B,0x1E,0x3C,0x00,0x3D,0x11,0x3E,0x00,0x3F,0x17,
0x40,0x00,0x41,0x11,0x42,0x00,0x43,0x17,0x44,0x00,0x45,0xE5,0x46,0x00,0x47,0xE7,0x48,0x00,0x49,0x00,0x4A,0x00,0x4B,0x00,0x4C,0x08,0x4D,0x00,0x4E,0x00,0x4F,0x06,
0x50,0x00,0x51,0x30,0x52,0x00,0x53,0x13,0x54,0x00,0x55,0x14,0x56,0x00,0x57,0x13,0x58,0x00,0x59,0x14,0x5A,0x00,0x5B,0x01,0x5C,0x00,0x5D,0x32,0x5E,0x00,0x5F,0x01,
0x60,0xE0,0x61,0xB0,0x62,0x00,0x63,0x0F,0x64,0x00,0x65,0x31,0x66,0x00,0x67,0x01,0x68,0x10,0x69,0x20,0x6A,0x00,0x6B,0x60,0x6C,0x00,0x6D,0xA0,0x6E,0x00,0x6F,0xF0,
0x70,0x00,0x71,0x0B,0x72,0x09,0x73,0x0B,0x74,0x9C,0x75,0x00,0x76,0x70,0x77,0x00,0x78,0x8F,0x79,0x00,0x7A,0xA4,0x7B,0x00,0x7C,0x00,0x7D,0x00,0x7E,0x1D,0x7F,0x40,
0x80,0x06,0x81,0x00,0x82,0x10,0x83,0x00,0x84,0x13,0x85,0x00,0x86,0x00,0x87,0x00,0x88,0x00,0x89,0x00,0x8A,0x57,0x8B,0x00,0x8C,0x00,0x8D,0x00,0x8E,0x00,0x8F,0x00,
0x90,0x40,0x91,0x00,0x92,0x00,0x93,0x00,0x94,0x00,0x95,0x00,0x96,0x00,0x97,0x00,0x98,0x80,0x99,0xFF,0x9A,0x80,0x9B,0xFF,0x9C,0x80,0x9D,0xFF,0x9E,0x80,0x9F,0xFF,
0xA0,0x40,0xA1,0x00,0xA2,0x00,0xA3,0x00,0xA4,0x80,0xA5,0xFF,0xA6,0x80,0xA7,0xFF,0xA8,0x00,0xA9,0x00,0xAA,0x00,0xAB,0x00,0xAC,0x80,0xAD,0xFF,0xAE,0x80,0xAF,0xFF,
0xB0,0x40,0xB1,0x00,0xB2,0x80,0xB3,0xFF,0xB4,0x00,0xB5,0x00,0xB6,0x80,0xB7,0xFF,0xB8,0x00,0xB9,0x00,0xBA,0x80,0xBB,0xFF,0xBC,0x00,0xBD,0x00,0xBE,0x80,0xBF,0xFF,
0xC0,0x02,0xC1,0x00,0xC2,0x0A,0xC3,0x0A,0xC4,0x0A,0xC5,0x0A,0xC6,0x0A,0xC7,0x0A,0xC8,0x0A,0xC9,0x0A,0xCA,0x0A,0xCB,0x0A,0xCC,0x0A,0xCD,0x0A,0xCE,0x0A,0xCF,0x0A,
0xD0,0x0A,0xD1,0x0A,0xD2,0x0A,0xD3,0x0A,0xD4,0x0A,0xD5,0x0A,0xD6,0x0A,0xD7,0x0A,0xD8,0x0A,0xD9,0x0A,0xDA,0x0A,0xDB,0x0A,0xDC,0x0A,0xDD,0x0A,0xDE,0x0A,0xDF,0x0A,
0xE0,0x0A,0xE1,0x0A,0xE2,0x0A,0xE3,0x0A,0xE4,0x0A,0xE5,0x0A,0xE6,0x0A,0xE7,0x0A,0xE8,0x0A,0xE9,0x0A,0xEA,0x0A,0xEB,0x0A,0xEC,0x0A,0xED,0x0A,0xEE,0x0A,0xEF,0x0A,
0xF0,0x0A,0xF1,0x0A,0xF2,0x0A,0xF3,0x0A,0xF4,0x0A,0xF5,0x0A,0xF6,0x0A,0xF7,0x0A,0xF8,0x0A,0xF9,0x0A,0xFA,0x0A,0xFB,0x0A,0xFC,0x0A,0xFD,0x0A,0xFE,0x0A,0xFF,0x0A,
0x08,0x10,0x08,0x00,
0xFF,0xFF};
BYTE v43reg_320x234[]={ 
0x8A,0x3A,    
0xFF,0xFF};
BYTE v43reg_480x234[]={ 
0x8A,0x57,
0xFF,0xFF};

#if (I2C_FUNCTION == I2C_HW_MASTER_MODE)
void MX88V430WtRegFromTable(BYTE DevID, BYTE * SettingTable)	
{
	WORD TablePointer = 0, RegNumber = 0, RegValue = 0;

	RegNumber = *(SettingTable + TablePointer);
	RegValue = *(SettingTable + TablePointer + 1);
	while (!((RegNumber == 0xff) && (RegValue == 0xff)))
	{
		I2CM_WtReg8Data8(DevID, RegNumber, RegValue);
		TablePointer += 2;
		RegNumber = *(SettingTable + TablePointer);
		RegValue = *(SettingTable + TablePointer + 1);
	}
}
#else	
void MX88V430WtRegFromTable(BYTE DevID, BYTE * SettingTable)	
{
    WORD i;
    BYTE mask, data1;
    register GPIO *sGpio;
    DWORD clkLow, clkHigh, dataLow, dataHigh;

    sGpio = (GPIO *) (GPIO_BASE);
    sGpio->Gpcfg0 &= 0xfffcfffc;  //1111 1111 1111 1100, default function
    sGpio->Gpdat0 |= 0x00030000;  // GP0, GP1 output
	
    i = 0;
    do{
        // write
        if(IIC_SetValue(DevID, START) == IIC_NO_ACK) MP_DEBUG("NAK");// return IIC_NO_ACK;
        if(IIC_SetValue(*(SettingTable + i), IGNORE) == IIC_NO_ACK) MP_DEBUG("NAK ");// return IIC_NO_ACK;
        if(IIC_SetValue(*(SettingTable + i + 1), STOP) == IIC_NO_ACK) MP_DEBUG("NAK ");// return IIC_NO_ACK;
        
        #ifdef READ
            IODelay(50);
            // read
            if((i > 0) && (i % 2)){
                IIC_SetValue(DevID, START);
                IIC_SetValue(*(SettingTable + i - 1), IGNORE);
                enterData(DATA_HIGH);
                IIC_SetValue(DevID | 0x1, START);
                mask = IIC_GetValue();
                UartOutValue(mask, 2);
                UartOutText(" ");
            }
        #endif
        i+= 2;
    }
    while(!((*(SettingTable + i) == 0xFF) && (*(SettingTable + i + 1) == 0xFF)));
}
#endif



//#define READ       1
void MX88V430Init(){
    ST_PANEL *pstPanel = g_psSystemConfig->sScreenSetting.pstPanel;
	MX88V430WtRegFromTable(IIC_ID, (BYTE *)(&v43reg));
    if (pstPanel->wWidthInPix == 320 && pstPanel->wHeightInPix == 234)
    	MX88V430WtRegFromTable(IIC_ID, (BYTE *)(&v43reg_320x234));
    else if (pstPanel->wWidthInPix == 480 && pstPanel->wHeightInPix == 234)
	    MX88V430WtRegFromTable(IIC_ID, (BYTE *)(&v43reg_480x234));
    else
        MP_DEBUG("\n\rThis type of panel isn't supported!");
	return;    
}
#endif

