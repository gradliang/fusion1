/*** FileName     AudioDac_WM8750L.c** Auther       C.W Liu* Date         2009.05.05** Description  Driver for Wolfson CODEC WM8750L* */ #define LOCAL_DEBUG_ENABLE 0/*// Include section */#include "global612.h"#include "mpTrace.h"#include "audio_hal.h"#if (AUDIO_DAC == DAC_WM8750L)#define WM8750_DEVICE_ADDRESS    0x1b	// 0x1b = 0011011, use at mode pin value is 0#define WM8750_DELAY()	__asm("nop");__asm("nop");__asm("nop");__asm("nop");__asm("nop");__asm("nop");__asm("nop");__asm("nop");__asm("nop");__asm("nop");__asm("nop");__asm("nop");__asm("nop");__asm("nop");__asm("nop");__asm("nop");__asm("nop");__asm("nop");__asm("nop");__asm("nop");#define WM8750_SCLK_HIGH()		g_psGpio->Gpdat0  |= 0x10000040		//set pin7 up#define WM8750_SCLK_LOW()		g_psGpio->Gpdat0  &= 0xffffffbf		//set pin7 down#define WM8750_SDIN_HIGH()		g_psGpio->Gpdat0  |= 0x00000080		//set pin8 up#define WM8750_SDIN_LOW()		g_psGpio->Gpdat0  &= 0xffffff7f		//set pin8 down#define WM8750_SDIN_OUT()		g_psGpio->Gpdat0  |= 0x00800000		//set pin8 Out#define WM8750_SDIN_IN()		g_psGpio->Gpdat0  &= 0xff7fffff		//set pin8 In#define WM8750_SDIN_GET()		((g_psGpio->Gpdat0 & 0x80) >> 7)#define WM8750_OUT_BOTH      0	// Output audio data to Speaker and Earphone#define WM8750_OUT_EXCLUSIVE 1	// Output audio data to Speaker or Earphonestatic const U16 WM8750FSTab[] ={    0x100d,  //R8   set to usb 12 MHz mode. and default sampling freq to 8KHz    0x1033,  //R8   set to usb 12 MHz mode. and default sampling freq to 11.025KHz    0x1011,  //R8   set to usb 12 MHz mode. and default sampling freq to 12KHz    0x1015,  //R8   set to usb 12 MHz mode. and default sampling freq to 16KHz    0x1037,  //R8   set to usb 12 MHz mode. and default sampling freq to 22.050KHz    0x1039,  //R8   set to usb 12 MHz mode. and default sampling freq to 24KHz    0x1019,  //R8   set to usb 12 MHz mode. and default sampling freq to 32KHz    0x1023,  //R8   set to usb 12 MHz mode. and default sampling freq to 44.1KHz    0x1001,  //R8   set to usb 12 MHz mode. and default sampling freq to 48KHz    0x1001,  //R8   set to usb 12 MHz mode. and default sampling freq to 64KHz    0x103F,  //R8   set to usb 12 MHz mode. and default sampling freq to 88KHz    0x101D,  //R8   set to usb 12 MHz mode. and default sampling freq to 96KHz};//Caculation is based on CPU time 96MHzvoid DAC_delay_ns(DWORD ns){	DWORD i;	ns = ns / 10;	//One instruction consume 10ns	for(i = 0; i < ns; i++)		__asm("nop");}void _pullSDIN(BYTE data){	if(data)		WM8750_SDIN_HIGH();	else		WM8750_SDIN_LOW();}BYTE _checkAck(){	BYTE data = 1;	WM8750_SDIN_IN();	WM8750_DELAY();	WM8750_SCLK_HIGH();	DAC_delay_ns(400);	data = WM8750_SDIN_GET();	DAC_delay_ns(300);	WM8750_SCLK_LOW();	WM8750_DELAY();	WM8750_SDIN_OUT();	DAC_delay_ns(1500);	if(data){		mpDebugPrint("fuck wm8750 ack value...and latch up");		while(1);	}	return data;}// 2-wire serial control modeBYTE _setRegister(WORD data){	BYTE i, tmp;	//Initial PIN status	WM8750_SDIN_HIGH();	WM8750_SCLK_HIGH();	DAC_delay_ns(400);	// Start Condiction	WM8750_SDIN_LOW();	DAC_delay_ns(700);	WM8750_SCLK_LOW();	DAC_delay_ns(1500);	// Device address input stage	for(i = 0; i < 7; i++)	{		tmp = (WM8750_DEVICE_ADDRESS >> (6 - i)) & 0x1;		//mpDebugPrint("D%d  %d", i, tmp);		_pullSDIN(tmp);		WM8750_DELAY();		WM8750_SCLK_HIGH();		DAC_delay_ns(300);		WM8750_SCLK_LOW();		DAC_delay_ns(1500);	}	WM8750_SDIN_LOW();		//Set write command bit	WM8750_DELAY();	WM8750_SCLK_HIGH();	DAC_delay_ns(300);	WM8750_SCLK_LOW();	DAC_delay_ns(1500);	if(_checkAck())		return 0;	// Control byte1 stage	for(i = 0; i < 8; i++)	{		tmp = (data >>(15 - i)) & 0x1;		//mpDebugPrint("c1.%d  %d", i, tmp);		_pullSDIN(tmp);		WM8750_DELAY();		WM8750_SCLK_HIGH();		DAC_delay_ns(300);		WM8750_SCLK_LOW();		DAC_delay_ns(1500);	}	if(_checkAck())		return 0;		// Control byte2 stage	for(i = 0; i < 8; i++)	{		tmp = (data >>(7 - i)) & 0x1;		//mpDebugPrint("c2.%d  %d", i, tmp);		_pullSDIN(tmp);		WM8750_DELAY();		WM8750_SCLK_HIGH();		DAC_delay_ns(300);		WM8750_SCLK_LOW();		DAC_delay_ns(1500);	}	if(_checkAck())		return 0;	// Stop stage	WM8750_SCLK_HIGH();	DAC_delay_ns(700);	WM8750_SDIN_HIGH();	WM8750_DELAY();	return 1;}// 2-wire serial control modeBYTE _setRegister2(WORD addr, WORD data){	BYTE i, tmp;	//Initial PIN status	WM8750_SDIN_HIGH();	WM8750_SCLK_HIGH();	DAC_delay_ns(400);	// Start Condiction	WM8750_SDIN_LOW();	DAC_delay_ns(700);	WM8750_SCLK_LOW();	DAC_delay_ns(1500);	// Device address input stage	for(i = 0; i < 7; i++)	{		tmp = (WM8750_DEVICE_ADDRESS >> (6 - i)) & 0x1;		//mpDebugPrint("D%d  %d", i, tmp);		_pullSDIN(tmp);		WM8750_DELAY();		WM8750_SCLK_HIGH();		DAC_delay_ns(300);		WM8750_SCLK_LOW();		DAC_delay_ns(1500);	}	WM8750_SDIN_LOW();		//Set write command bit	WM8750_DELAY();	WM8750_SCLK_HIGH();	DAC_delay_ns(300);	WM8750_SCLK_LOW();	DAC_delay_ns(1500);	if(_checkAck())		return 0;	// Control byte1 stage	// Send address bits	for(i = 0; i < 7; i++)	{		tmp = (addr >>(6 - i)) & 0x1;		//mpDebugPrint("c1.%d  %d", i, tmp);		_pullSDIN(tmp);		WM8750_DELAY();		WM8750_SCLK_HIGH();		DAC_delay_ns(300);		WM8750_SCLK_LOW();		DAC_delay_ns(1500);	}	// Send data bit8	tmp = (data >> 8) & 0x1;	//mpDebugPrint("c1.7  %d", tmp);	_pullSDIN(tmp);	WM8750_DELAY();	WM8750_SCLK_HIGH();	DAC_delay_ns(300);	WM8750_SCLK_LOW();	DAC_delay_ns(1500);	if(_checkAck())		return 0;		// Control byte2 stage	for(i = 0; i < 8; i++)	{		tmp = (data >>(7 - i)) & 0x1;		//mpDebugPrint("c2.%d  %d", i, tmp);		_pullSDIN(tmp);		WM8750_DELAY();		WM8750_SCLK_HIGH();		DAC_delay_ns(300);		WM8750_SCLK_LOW();		DAC_delay_ns(1500);	}	if(_checkAck())		return 0;	// Stop stage	WM8750_SCLK_HIGH();	DAC_delay_ns(700);	WM8750_SDIN_HIGH();	WM8750_DELAY();	return 1;}// Set the GPIO condition for I2S communicationvoid WM8750L_GPIO_Init(){	g_psGpio->Gpcfg0  &= 0xff1fff1f;		//set gp5~7 as default function	g_psGpio->Gpdat0  |= 0x00e00000;		//Output	}void WM8750L_RecordTestingRoutine(){}void WM8750L_Set_PLAYBACKmode(){}void WM8750L_Set_RECORDmode(){	static U16 WMInitADCTab[]=	{	    0x33fe,  //R25 << Power up VMID[50Kohm]; VREF; AINL/R & ADCL/R>>	    0x013f,  //R0  << Set Left Input Volume Update bit to ．1・ & Volume Level to default >>	    0x033f,  //R1  << Set Right Input Volume Update bit to ．1・ & Volume Level to default >>	    0x0e42,  //R7  << set to master mode, 16bit, i2s >>	    0x100d,  //R8  << set to usb 12 MHz mode. and default sampling freq to 8KHz >>	    0x2bff,  //R21 << Set Left ADC Volume Update bit to ．1・ & Volume Level to default >>	    0x2dff,  //R22 << Set Right ADC Volume Update bit to ．1・ & Volume Level to default >>	    0x2000,  //R16 << Set 3D function off, the default is used for recording >>	    0x35f8,  //R26   << Power up R/LOUT1 & R/LOUT2 leaving DACL/R set>>	    0x4080,  //R32  set input from linein 3	    0x4280,  //R33  set input from linein 3	    0x32fe,  //R25 << Power up VMID[50Kohm]; VREF; AINL/R & ADCL/R>>	};}/* *    Mapping 16 level of UI volune value to 128 level hardware value */void WM8750L_ChgVolume(WORD vol){	mpDebugPrint("WM8750 volume level: %d", vol);	if(vol == 16)		vol = 63;	else		vol = vol << 2;	//mpDebugPrint("	volume level: %d", vol);	//mpDebugPrint("		%x", 0x0540 + vol);	//mpDebugPrint("		%x", 0x0740 + vol);	//mpDebugPrint("		%x", 0x5140 + vol);	//mpDebugPrint("		%x", 0x5340 + vol);	// LOUT1 volume setting	_setRegister2(0x02, 0x140 + vol);  //R2	_setRegister2(0x03, 0x140 + vol);  //R3	// LOUT2 volume setting	_setRegister2(0x28, 0x140 + vol);  //R40	_setRegister2(0x29, 0x140 + vol);  //R41}BYTE WM8750L_CheckHPConnect(){	return 1;}// Will be finished after getting MP650 real board!!!!!!!!!!!!!!!!!!!!!!!!void WM8750L_SelOutput(BYTE mode){	switch(mode)	{		case WM8750_OUT_BOTH:			_setRegister2(0x18, 0x010);			break;		case WM8750_OUT_EXCLUSIVE:			_setRegister2(0x18, 0x050);			break;	}}// This sample rate setting refrences WM8750L datasheet REV 4.2 Page.46// The crystal frequency is based on 13.5 HZvoid WM8750L_SetDACSampleRate(DWORD sRate){	mpDebugPrint("WM8750L Samplerate: %d", sRate);		if (     (sRate > 7000)  && (sRate < 11000))	// Set 8kHz status	{		_setRegister2(0x08, 0x0c);	}	else if((sRate >= 11000) && (sRate < 14000))	// Set 12kHz status	{		_setRegister2(0x08, 0x10);	}	else if((sRate >= 14000) && (sRate < 22000))	// Set 16kHz status	{		_setRegister2(0x08, 0x14);	}	else if((sRate >= 22000) && (sRate < 30000))	// Set 24kHz status	{		_setRegister2(0x08, 0x38);	}	else if((sRate >= 30000) && (sRate < 36000))	// Set 32kHz status	{		_setRegister2(0x08, 0x18);	}	else if((sRate >= 36000) && (sRate < 46000))	// Set 44.1kHz status	{		// The MCLK is running at 11.2896MHZ		g_psClock->PLL3Cfg    =  0x00020405;		g_psClock->AudClkC    =  0x00001300;        //MCLK = PLL3, ACLK = PLL3/4		_setRegister2(0x08, 0x28);	}	else if((sRate >= 36000) && (sRate < 64000))	// Set 48kHz status	{		_setRegister2(0x08, 0x08);	}	else if((sRate >= 64000) && (sRate < 97000))	// Set 96kHz status	{		_setRegister2(0x08, 0x1c);	}	else		mpDebugPrint("Samplerate %d is not support  by IIS.(8K--96K support)", sRate);	// If you want to change PLL value, follow below steps	// 1. setting PLL config.	// 2. Disable PLL (ClkCtrl , Clkss_EXT1)	// 3. Re-enable PLL(ClkCtrl , Clkss_EXT1)	g_psClock->Clkss_EXT1 &= 0xfffffff0;	g_psClock->Clkss_EXT1 |= (BIT3);    // Using PLL3/1 to be clock source//	g_psClock->Clkss_EXT1 =  0x00000008;    //PLL3 enable	g_psClock->ClkCtrl &= ~0x01000000;		// enable PLL3	g_psClock->ClkCtrl |= 0x01000000;		// enable PLL3}// Setting AIU registers and reset sample rate void  WM8750L_PlayConfig(DWORD sampleRate){	AIU_PLAYBACK_GAI_INIT();	//g_psAiu->AiuCtl  = 0x60800040; //Enable GAI_EN, FIFO_CLR, PLY_EN, FSH_MASK	AIU_SET_GENERAL_WAVEFORM();	AIU_SET_LRCLOCK_LEN(0x3f);	WM8750L_SetDACSampleRate(sampleRate);}/** *************************************************************** * * Config WM8750L clock and gpio * *  Input  : none. * *  Output : none.  ****************************************************************/  void WM8750L_AIUCfg(void){	g_psClock->ClkCtrl |= 0x01000000;	// enable PLL3	g_psClock->AudClkC = 0x00001310;	//for PLL3  /2 =MCLK/4=ACLK	g_psClock->Clkss_EXT1 |= (BIT3);    // Using PLL3/1 to be clock source	//g_psClock->Clkss_EXT1 = 0x00000008;	//for PLL3/1 and enable	// Select External Bit_Clock Source	//g_psClock->MdClken &= 0xFFFeFFFF;	//CKE_AUDB disable,  c cke_ac97 disable	//g_psClock->MdClken |= 0x00018000;	//1: CKE_AUDB enable  CKE_AUDM enable	AIUCLOCK_DISABLE();	AIU_MAINCLOCK_ENABLE();		// Disable AIU_DMA	g_psDmaAiu->Control = 0x00000000;		// Configure AGPIO to AUDIO Mode	g_psGpio->Agpcfg = 0x0000001F;		WM8750L_GPIO_Init();}inline void AudioInit_WM8750L(void){	mpDebugPrint("Audio dec init...WM8750L");	register INTERRUPT *interrupt;	WM8750L_AIUCfg();	interrupt = (INTERRUPT *)(INT_BASE);	interrupt->MiMask |= 0x00000800;		//enable AUDIO module interrupt	_setRegister(0x33c0);    // R25  --  Power managment 1 Open	_setRegister(0x35f8);    // R26  --  Power managnent 2 Open	_setRegister(0x0a00);    // R5   --  Clean DAC mute bit	_setRegister(0x0e00);    // R7   --  Set Slave mode and Audio data format//	_setRegister2(0x07, 0x040);	   // R7   --  Set Master mode and Audio data format	_setRegister(0x1000);    // R8   --  Sample rate setting	_setRegister(0x32cc);    // R25  --  Power up VMID[50kohm]	_setRegister(0x4550);    // R34  --  Set the LD2LO bit (L DAC --> L output)	_setRegister(0x4b50);    // R37  --  Set the RD2RO bit (R DAC --> R output)	_setRegister(0x15ff);    // R10  --  Set LDAC volume	_setRegister(0x17ff);    // R11  --  Set RDAC volume	_setRegister(0x3010);    // R24  --  Destination Output control}inline void AudioInitRec_WM8750L(void){	mpDebugPrint("Audio Rec init...WM8750L");	register INTERRUPT *interrupt;	WM8750L_AIUCfg();	interrupt = (INTERRUPT *)(INT_BASE);	interrupt->MiMask |= 0x00000800;		//enable AUDIO module interrupt	_setRegister(0x33fe);  //R25 << Power up VMID[50Kohm]; VREF; AINL/R & ADCL/R>>	_setRegister(0x013f);  //R0  << Set Left Input Volume Update bit to ．1・ & Volume Level to default >>	_setRegister(0x033f);  //R1  << Set Right Input Volume Update bit to ．1・ & Volume Level to default >>	_setRegister(0x0e42);  //R7  << set to master mode, 16bit, i2s >>	_setRegister(0x100d);  //R8  << set to usb 12 MHz mode. and default sampling freq to 8KHz >>	_setRegister(0x2bff);  //R21 << Set Left ADC Volume Update bit to ．1・ & Volume Level to default >>	_setRegister(0x2dff);  //R22 << Set Right ADC Volume Update bit to ．1・ & Volume Level to default >>	_setRegister(0x2000);  //R16 << Set 3D function off, the default is used for recording >>	_setRegister(0x35f8);  //R26   << Power up R/LOUT1 & R/LOUT2 leaving DACL/R set>>	_setRegister(0x4080);  //R32  set input from linein 3	_setRegister(0x4280);  //R33  set input from linein 3	_setRegister(0x32fe);  //R25 << Power up VMID[50Kohm]; VREF; AINL/R & ADCL/R>>}HAL_AUDIODAC_T _audioDAC_WM8750 ={	AudioInitRec_WM8750L,	NULL,	NULL,	WM8750L_PlayConfig,	NULL,	WM8750L_ChgVolume};#endif