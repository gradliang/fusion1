/*** FileName     AudioDac_WM8960.c** Auther       XW Chang* Date         2009.05.05** Description  Driver for Wolfson CODEC WM8960* */ #define LOCAL_DEBUG_ENABLE 0/*// Include section */#include "global612.h"#include "mpTrace.h"#include "audio_hal.h"#if (AUDIO_DAC == DAC_WM8960)#define WM8960_DEVICE_ADDRESS    0x1A	// 0x1b = 0011010, use at mode pin value is 0#define WM8960_DELAY()	__asm("nop");__asm("nop");__asm("nop");__asm("nop");__asm("nop");__asm("nop");__asm("nop");__asm("nop");__asm("nop");__asm("nop");__asm("nop");__asm("nop");__asm("nop");__asm("nop");__asm("nop");__asm("nop");__asm("nop");__asm("nop");__asm("nop");__asm("nop");#if IICM_PIN_USING_VGPIO#define WM8960_SCLK_HIGH()		g_psGpio->Vgpdat1  |=  0x00000080		//set pin1 up#define WM8960_SCLK_LOW()		g_psGpio->Vgpdat1  &= ~0x00000080		//set pin1 down#define WM8960_SDIN_HIGH()		g_psGpio->Vgpdat1  |=  0x00000100		//set pin2 up#define WM8960_SDIN_LOW()		g_psGpio->Vgpdat1  &= ~0x00000100		//set pin2 down#define WM8960_SDIN_OUT()		g_psGpio->Vgpdat1  |=  0x01000000		//set pin2 Out#define WM8960_SDIN_IN()		g_psGpio->Vgpdat1  &= ~0x01000000		//set pin2 In#define WM8960_SDIN_GET()		((g_psGpio->Vgpdat1 & 0x100) >> 8)#else#define WM8960_SCLK_HIGH()		g_psGpio->Gpdat0  |=  0x00000001		//set pin1 up#define WM8960_SCLK_LOW()		g_psGpio->Gpdat0  &= ~0x00000001		//set pin1 down#define WM8960_SDIN_HIGH()		g_psGpio->Gpdat0  |=  0x00000002		//set pin2 up#define WM8960_SDIN_LOW()		g_psGpio->Gpdat0  &= ~0x00000002		//set pin2 down#define WM8960_SDIN_OUT()		g_psGpio->Gpdat0  |=  0x00020000		//set pin2 Out#define WM8960_SDIN_IN()		g_psGpio->Gpdat0  &= ~0x00020000		//set pin2 In#define WM8960_SDIN_GET()		((g_psGpio->Gpdat0 & 0x02) >> 1)#endif#define WM8960_OUT_BOTH      0	// Output audio data to Speaker and Earphone#define WM8960_OUT_EXCLUSIVE 1	// Output audio data to Speaker or Earphone#if RECORD_AUDIO#define WM8960_USINGHWI2C    DISABLE#else#define WM8960_USINGHWI2C    ENABLE#endif//Caculation is based on CPU time 96MHzvoid DAC_delay_ns1(DWORD ns){	DWORD i;	ns = ns / 5;	//One instruction consume 10ns	for(i = 0; i < ns; i++)		__asm("nop");}#if(WM8960_USINGHWI2C != ENABLE)void _pullSDIN(BYTE data){	if(data)		WM8960_SDIN_HIGH();	else		WM8960_SDIN_LOW();}BYTE _checkAck(){	BYTE data = 1;	DWORD StartTime;				WM8960_SDIN_IN();	WM8960_DELAY();	WM8960_SCLK_HIGH();	DAC_delay_ns1(400);	data = WM8960_SDIN_GET();	DAC_delay_ns1(300);	WM8960_SCLK_LOW();	WM8960_DELAY();	WM8960_SDIN_OUT();	DAC_delay_ns1(1500);	if(data){		StartTime = GetSysTime();		while(1)		{			if(SystemGetElapsedTime(StartTime) > 128)			{				mpDebugPrint("WM8960 can not get correct value and latch up");				break;			}		}	}	return data;}// 2-wire serial control modestatic BYTE _setRegister(WORD data){	BYTE i, tmp;	//Initial PIN status	WM8960_SDIN_HIGH();	WM8960_SCLK_HIGH();	DAC_delay_ns1(400);	// Start Condiction	WM8960_SDIN_LOW();	DAC_delay_ns1(700);	WM8960_SCLK_LOW();	DAC_delay_ns1(1500);	// Device address input stage	for(i = 0; i < 7; i++)	{		tmp = (WM8960_DEVICE_ADDRESS >> (6 - i)) & 0x1;		//mpDebugPrint("D%d  %d", i, tmp);		_pullSDIN(tmp);		WM8960_DELAY();		WM8960_SCLK_HIGH();		DAC_delay_ns1(300);		WM8960_SCLK_LOW();		DAC_delay_ns1(1500);	}	WM8960_SDIN_LOW();		//Set write command bit	WM8960_DELAY();	WM8960_SCLK_HIGH();	DAC_delay_ns1(300);	WM8960_SCLK_LOW();	DAC_delay_ns1(1500);	if(_checkAck())		return 0;	// Control byte1 stage	for(i = 0; i < 8; i++)	{		tmp = (data >>(15 - i)) & 0x1;		//mpDebugPrint("c1.%d  %d", i, tmp);		_pullSDIN(tmp);		WM8960_DELAY();		WM8960_SCLK_HIGH();		DAC_delay_ns1(300);		WM8960_SCLK_LOW();		DAC_delay_ns1(1500);	}	if(_checkAck())		return 0;		// Control byte2 stage	for(i = 0; i < 8; i++)	{		tmp = (data >>(7 - i)) & 0x1;		//mpDebugPrint("c2.%d  %d", i, tmp);		_pullSDIN(tmp);		WM8960_DELAY();		WM8960_SCLK_HIGH();		DAC_delay_ns1(300);		WM8960_SCLK_LOW();		DAC_delay_ns1(1500);	}	if(_checkAck())		return 0;	// Stop stage	WM8960_SCLK_HIGH();	DAC_delay_ns1(700);	WM8960_SDIN_HIGH();	WM8960_DELAY();	return 1;}// 2-wire serial control modestatic BYTE _setRegister2(WORD addr, WORD data){	BYTE i, tmp;	//Initial PIN status	WM8960_SDIN_HIGH();	WM8960_SCLK_HIGH();	DAC_delay_ns1(400);	// Start Condiction	WM8960_SDIN_LOW();	DAC_delay_ns1(700);	WM8960_SCLK_LOW();	DAC_delay_ns1(1500);	// Device address input stage	for(i = 0; i < 7; i++)	{		tmp = (WM8960_DEVICE_ADDRESS >> (6 - i)) & 0x1;		//mpDebugPrint("D%d  %d", i, tmp);		_pullSDIN(tmp);		WM8960_DELAY();		WM8960_SCLK_HIGH();		DAC_delay_ns1(300);		WM8960_SCLK_LOW();		DAC_delay_ns1(1500);	}	WM8960_SDIN_LOW();		//Set write command bit	WM8960_DELAY();	WM8960_SCLK_HIGH();	DAC_delay_ns1(300);	WM8960_SCLK_LOW();	DAC_delay_ns1(1500);	if(_checkAck())		return 0;	// Control byte1 stage	// Send address bits	for(i = 0; i < 7; i++)	{		tmp = (addr >>(6 - i)) & 0x1;		//mpDebugPrint("c1.%d  %d", i, tmp);		_pullSDIN(tmp);		WM8960_DELAY();		WM8960_SCLK_HIGH();		DAC_delay_ns1(300);		WM8960_SCLK_LOW();		DAC_delay_ns1(1500);	}	// Send data bit8	tmp = (data >> 8) & 0x1;	//mpDebugPrint("c1.7  %d", tmp);	_pullSDIN(tmp);	WM8960_DELAY();	WM8960_SCLK_HIGH();	DAC_delay_ns1(300);	WM8960_SCLK_LOW();	DAC_delay_ns1(1500);	if(_checkAck())		return 0;		// Control byte2 stage	for(i = 0; i < 8; i++)	{		tmp = (data >>(7 - i)) & 0x1;		//mpDebugPrint("c2.%d  %d", i, tmp);		_pullSDIN(tmp);		WM8960_DELAY();		WM8960_SCLK_HIGH();		DAC_delay_ns1(300);		WM8960_SCLK_LOW();		DAC_delay_ns1(1500);	}	if(_checkAck())		return 0;	// Stop stage	WM8960_SCLK_HIGH();	DAC_delay_ns1(700);	WM8960_SDIN_HIGH();	WM8960_DELAY();	return 1;}#elsestatic BYTE _setRegister2(WORD addr, WORD data){	SDWORD readBack;	BYTE addr_temp;	WORD data_temp;	addr_temp = (addr<<1)| (data >>8 & 0x1);	data_temp = (data & 0xFF);	I2CM_WtReg8Data8(WM8960_DEVICE_ADDRESS << 1, (BYTE)addr_temp, data_temp);	//MP_ALERT("%s - Addr = 0x%04X, 0x%04X, 0x%04X", __FUNCTION__, (DWORD) addr, (DWORD) data, (DWORD) readBack);	return 0;}static BYTE _readRegister(WORD addr, DWORD *data){	*data = I2CM_RdReg8Data8(WM8960_DEVICE_ADDRESS << 1, (BYTE)addr);	return 0;}#endif// Set the GPIO condition for I2S communicationstatic DWORD gpcfg1;static DWORD gpdat1;void WM8960_GPIO_Init(){#if IICM_PIN_USING_VGPIO	//It saved vgpio1 value because it may have other function have set it.	//Record it and restore it after finishing to set WM8960  XianWen Chang 2010/06/24	gpcfg1 = g_psGpio->Vgpcfg1;	gpdat1 = g_psGpio->Vgpdat1;	g_psGpio->Vgpcfg1 &= 0xFE7FFE7F;	g_psGpio->Vgpdat1 |= 0x01800000;	#else	gpcfg1 = g_psGpio->Gpcfg0;	gpdat1 = g_psGpio->Gpdat0;	g_psGpio->Gpcfg0  &= 0xfffcfffc;		//set gp0~1 as default function	g_psGpio->Gpdat0  |= 0x00030000;		//Output#endif}/* *    Mapping 16 level of UI volune value to 128 level hardware value */void WM8960_ChgVolume(WORD vol){	mpDebugPrint("WM8960 volume level: %d", vol);	WORD wvol;	wvol = 7*vol-1;	if (vol>=16)		wvol = 0x7F;	WM8960_GPIO_Init();	_setRegister2(0x02,0x100+wvol);	_setRegister2(0x03,0x100+wvol);	_setRegister2(0x28,0x100+wvol);	_setRegister2(0x29,0x100+wvol);		_setRegister2(0x15,0x100+wvol);	_setRegister2(0x16,0x100+wvol);		//Set a constant value, it will be removed ASAP	//Headphone Volume	_setRegister2(0x02,0x065);	_setRegister2(0x03,0x165);	//Speaker Volume	_setRegister2(0x28,0x079);	_setRegister2(0x29,0x179);	//Mic Volume	_setRegister2(0x15,0x1AF);	_setRegister2(0x16,0x1AF);	#if (WM8960_USINGHWI2C == DISABLE && IICM_PIN_USING_VGPIO) 			g_psGpio->Vgpcfg1 = gpcfg1;		g_psGpio->Vgpdat1 = gpdat1;#else if (WM8960_USINGHWI2C == DISABLE && !IICM_PIN_USING_VGPIO)		g_psGpio->Gpcfg0  = gpcfg1;		//set gp0~1 as default function		g_psGpio->Gpdat0  = gpdat1;		//Output		#endif		}void WM8960_SetDACSampleRate(DWORD sRate){	register CLOCK *audio_clock;	int data;	audio_clock = (CLOCK *) (CLOCK_BASE);	audio_clock->PLL3Cfg = 0x00770107;	int PLL2CLOCK = (Clock_PllFreqGet(CLOCK_PLL2_INDEX)/1000000);	if (AUDIO_DAC_USING_PLL2)	{		if((PLL2CLOCK == 120) || (PLL2CLOCK == 138) || (PLL2CLOCK == 144) || (PLL2CLOCK == 153) || 			(PLL2CLOCK == 160) || (PLL2CLOCK == 166) )			{				mpDebugPrint("WM8960 using PLL2 Clock Freq: %d", PLL2CLOCK);			}		else		{			goto not_supported_samplerate;		}	}	else		mpDebugPrint("WM8960 using PLL3");	mpDebugPrint("WM8960 Samplerate: %d", sRate);	if (     (sRate > 7000)  && (sRate < 11000))	// Set 8kHz status	{#if RECORD_AUDIO			_setRegister2(0x04,0x1B0);//_setRegister2(0x04,0x30);#else		_setRegister2(0x04,0x1B0);#endif	#if AUDIO_DAC_USING_PLL2		if 		(PLL2CLOCK == 120)			{	        audio_clock->AudClkC = 0x0000151C;//120/5/2 = 12Mhz	        AIU_SET_LRCLOCK_LEN(0xF9);			}		else if (PLL2CLOCK == 138)			{	        audio_clock->AudClkC = 0x0000151D;//138/6/2 = 11.5Mhz	        AIU_SET_LRCLOCK_LEN(0xEE); 					}		else if (PLL2CLOCK == 144)        	{        	audio_clock->AudClkC = 0x0000151D;//144/6/2 = 12Mhz	        AIU_SET_LRCLOCK_LEN(0xF9);			}		else if (PLL2CLOCK == 153)			{	        audio_clock->AudClkC = 0x0000161D;//153/6/2 = 12.75Mhz	        AIU_SET_LRCLOCK_LEN(0xE3);			}		else if (PLL2CLOCK == 160)			{	        audio_clock->AudClkC = 0x0000151E;//160/7/2 =11.43Mhz	        AIU_SET_LRCLOCK_LEN(0xED);			}		else if (PLL2CLOCK == 166)			{			audio_clock->AudClkC = 0x0000151E;//166/7/2 =11.85Mhz	        AIU_SET_LRCLOCK_LEN(0xF6);			}	#else		audio_clock->PLL3Cfg = 0x00777C7F;		audio_clock->AudClkC = 0x00001500;			AIU_SET_LRCLOCK_LEN(0xFF);					//AIU_SET_LRCLOCK_LEN(0xFF);	#endif		}	else if((sRate >= 11000) && (sRate < 11300))	// Set 11.025kHz status	{		_setRegister2(0x04,0x20);		#if AUDIO_DAC_USING_PLL2		if 		(PLL2CLOCK == 120)        	{        	audio_clock->AudClkC = 0x0000141C;//120/5/2 = 12Mhz        	AIU_SET_LRCLOCK_LEN(0xD9);  					}		else if (PLL2CLOCK == 138)			{	        audio_clock->AudClkC = 0x0000141D;//138/6/2 = 11.5Mhz	        AIU_SET_LRCLOCK_LEN(0xD0); 				}		else if (PLL2CLOCK == 144)			{	        audio_clock->AudClkC = 0x0000141D;//144/6/2 = 12Mhz	        AIU_SET_LRCLOCK_LEN(0xD9);    					}		else if (PLL2CLOCK == 153)			{	        audio_clock->AudClkC = 0x0000141D;//153/6/2 = 12.75Mhz	        AIU_SET_LRCLOCK_LEN(0xE7); 			}		else if (PLL2CLOCK == 160)			{	        audio_clock->AudClkC = 0x0000141E;//160/7/2 =11.43Mhz	        AIU_SET_LRCLOCK_LEN(0xCA);			}		else if (PLL2CLOCK == 166)			{	        audio_clock->AudClkC = 0x0000141E;//166/7/2 =11.85Mhz	        AIU_SET_LRCLOCK_LEN(0xD2);			}	#else			audio_clock->PLL3Cfg = 0x0077107F;		audio_clock->AudClkC = 0x00001370;			AIU_SET_LRCLOCK_LEN(0xFF);	#endif		}	else if((sRate >= 11300) && (sRate < 14000))	// Set 12kHz status	{		_setRegister2(0x04,0x20);			#if AUDIO_DAC_USING_PLL2		if 		(PLL2CLOCK == 120)			{	        audio_clock->AudClkC = 0x0000131C;//120/5/2 = 12Mhz	        AIU_SET_LRCLOCK_LEN(0xFF);  					}		else if (PLL2CLOCK == 138)			{	        audio_clock->AudClkC = 0x0000131D;//138/6/2 = 11.5Mhz	        AIU_SET_LRCLOCK_LEN(0xEF);      					}		else if (PLL2CLOCK == 144)			{	        audio_clock->AudClkC = 0x0000131D;//144/6/2 = 12Mhz	        AIU_SET_LRCLOCK_LEN(0xFF);  					}		else if (PLL2CLOCK == 153)			{	        audio_clock->AudClkC = 0x0000141D;//153/6/2 = 12.75Mhz	        AIU_SET_LRCLOCK_LEN(0xD4); 			}		else if (PLL2CLOCK == 160)			{	        audio_clock->AudClkC = 0x0000131E;//160/7/2 =11.43Mhz	        AIU_SET_LRCLOCK_LEN(0xED);			}		else if (PLL2CLOCK == 166)			{	        audio_clock->AudClkC = 0x0000131E;//166/7/2 =11.85Mhz	        AIU_SET_LRCLOCK_LEN(0xF6);			}	#else		audio_clock->PLL3Cfg = 0x007718cc;		audio_clock->AudClkC = 0x00001370;		AIU_SET_LRCLOCK_LEN(0xFF);			#endif		}	else if((sRate >= 14000) && (sRate < 22000))	// Set 16kHz status	{		_setRegister2(0x04,0x18);		#if AUDIO_DAC_USING_PLL2		if 		(PLL2CLOCK == 120)			{	        audio_clock->AudClkC = 0x0000121C;//120/5/2 = 12Mhz	        AIU_SET_LRCLOCK_LEN(0xFA);  					}		else if (PLL2CLOCK == 138)			{	        audio_clock->AudClkC = 0x0000121D;//138/6/2 = 11.5Mhz	        AIU_SET_LRCLOCK_LEN(0xEF); 					}		else if (PLL2CLOCK == 144)			{	        audio_clock->AudClkC = 0x0000121D;//144/6/2 = 12Mhz	        AIU_SET_LRCLOCK_LEN(0xFA);  					}		else if (PLL2CLOCK == 153)			{	        audio_clock->AudClkC = 0x0000131D;//153/6/2 = 12.75Mhz	        AIU_SET_LRCLOCK_LEN(0xC7);			}		else if (PLL2CLOCK == 160)			{	        audio_clock->AudClkC = 0x0000121E;//160/7/2 =11.43Mhz	        AIU_SET_LRCLOCK_LEN(0xED);			}		else if (PLL2CLOCK == 166)			{	        audio_clock->AudClkC = 0x0000121E;//166/7/2 =11.85Mhz	        AIU_SET_LRCLOCK_LEN(0xF6);			}	#else		audio_clock->PLL3Cfg = 0x007718cc;		audio_clock->AudClkC = 0x00001270;			AIU_SET_LRCLOCK_LEN(0xFF);			#endif		}	else if((sRate >= 20000) && (sRate < 23000))	// Set 22.05Hz status	{		_setRegister2(0x04,0x10);	#if AUDIO_DAC_USING_PLL2		if 		(PLL2CLOCK == 120)			{	        audio_clock->AudClkC = 0x0000131C;//120/5/2 = 12Mhz	        AIU_SET_LRCLOCK_LEN(0x88);   					}		else if (PLL2CLOCK == 138)			{	        audio_clock->AudClkC = 0x0000131D;//138/6/2 = 11.5Mhz	        AIU_SET_LRCLOCK_LEN(0x82);  					}		else if (PLL2CLOCK == 144)			{	        audio_clock->AudClkC = 0x0000131D;//144/6/2 = 12Mhz	        AIU_SET_LRCLOCK_LEN(0x88);   					}		else if (PLL2CLOCK == 153)			{	        audio_clock->AudClkC = 0x0000141D;//153/6/2 = 12.75Mhz	        AIU_SET_LRCLOCK_LEN(0x73);			}		else if (PLL2CLOCK == 160)			{	        audio_clock->AudClkC = 0x0000131E;//160/7/2 =11.43Mhz	        AIU_SET_LRCLOCK_LEN(0x81);			}		else if (PLL2CLOCK == 166)			{	        audio_clock->AudClkC = 0x0000131E;//166/7/2 =11.85Mhz	        AIU_SET_LRCLOCK_LEN(0x85);			}	#else		audio_clock->PLL3Cfg = 0x0077107F;//MCLK ==11.289Mhz		audio_clock->AudClkC = 0x00001170;				AIU_SET_LRCLOCK_LEN(0xFF);	#endif	}	else if((sRate >= 22000) && (sRate < 30000))	// Set 24kHz status	{		_setRegister2(0x04, 0x10);	#if AUDIO_DAC_USING_PLL2		if 		(PLL2CLOCK == 120)			{	        audio_clock->AudClkC = 0x0000131C;//120/5/2 = 12Mhz	        AIU_SET_LRCLOCK_LEN(0x7C); 					}		else if (PLL2CLOCK == 138)			{	        audio_clock->AudClkC = 0x0000131D;//138/6/2 = 11.5Mhz	        AIU_SET_LRCLOCK_LEN(0x77);					}		else if (PLL2CLOCK == 144)			{	        audio_clock->AudClkC = 0x0000131D;//144/6/2 = 12Mhz	        AIU_SET_LRCLOCK_LEN(0x7C);    					}		else if (PLL2CLOCK == 153)			{	       	audio_clock->AudClkC = 0x0000141D;//153/6/2 = 12.75Mhz	        AIU_SET_LRCLOCK_LEN(0x69);			}		else if (PLL2CLOCK == 160)			{	        audio_clock->AudClkC = 0x0000131E;//160/7/2 =11.43Mhz	        AIU_SET_LRCLOCK_LEN(0x76);			}		else if (PLL2CLOCK == 166)			{	        audio_clock->AudClkC = 0x0000131E;//166/7/2 =11.85Mhz	        AIU_SET_LRCLOCK_LEN(0x7B);			}	#else			audio_clock->PLL3Cfg = 0x007718cc;		audio_clock->AudClkC = 0x00001170;			AIU_SET_LRCLOCK_LEN(0xFF);	#endif		}	else if((sRate >= 30000) && (sRate < 36000))	// Set 32kHz status	{		_setRegister2(0x04,0x08);		#if AUDIO_DAC_USING_PLL2		if 		(PLL2CLOCK == 120)			{	        audio_clock->AudClkC = 0x0000121C;//120/5/2 = 12Mhz	        AIU_SET_LRCLOCK_LEN(0x7C);					}		else if (PLL2CLOCK == 138)			{	        audio_clock->AudClkC = 0x0000121D;//138/6/2 = 11.5Mhz	        AIU_SET_LRCLOCK_LEN(0x77); 					}		else if (PLL2CLOCK == 144)			{	        audio_clock->AudClkC = 0x0000121D;//144/6/2 = 12Mhz	        AIU_SET_LRCLOCK_LEN(0x7C);  					}		else if (PLL2CLOCK == 153)			{	        audio_clock->AudClkC = 0x0000121D;//153/6/2 = 12.75Mhz	        AIU_SET_LRCLOCK_LEN(0x84); 			}		else if (PLL2CLOCK == 160)			{	        audio_clock->AudClkC = 0x0000121E;//160/7/2 =11.43Mhz	        AIU_SET_LRCLOCK_LEN(0x76);			}		else if (PLL2CLOCK == 166)			{	        audio_clock->AudClkC = 0x0000121E;//166/7/2 =11.85Mhz	        AIU_SET_LRCLOCK_LEN(0x7B);			}	#else			audio_clock->PLL3Cfg = 0x007718cc;		audio_clock->AudClkC = 0x00001270;			AIU_SET_LRCLOCK_LEN(0x7F);	#endif		}	else if((sRate >= 36000) && (sRate < 46000))	// Set 44.1kHz status	{		_setRegister2(0x04,0x00);	#if AUDIO_DAC_USING_PLL2		if 		(PLL2CLOCK == 120)			{	        audio_clock->AudClkC = 0x0000111C;//120/5/2 = 12Mhz	        AIU_SET_LRCLOCK_LEN(0x85);   					}		else if (PLL2CLOCK == 138)			{	        audio_clock->AudClkC = 0x0000111D;//138/6/2 = 11.5Mhz	        AIU_SET_LRCLOCK_LEN(0x82);  					}		else if (PLL2CLOCK == 144)			{	        audio_clock->AudClkC = 0x0000111D;//144/6/2 = 12Mhz	        AIU_SET_LRCLOCK_LEN(0x87);   					}		else if (PLL2CLOCK == 153)			{	        audio_clock->AudClkC = 0x0000111D;//153/6/2 = 12.75Mhz	        AIU_SET_LRCLOCK_LEN(0x8E); 			}		else if (PLL2CLOCK == 160)			{	        audio_clock->AudClkC = 0x0000111E;//160/7/2 =11.43Mhz	        AIU_SET_LRCLOCK_LEN(0x81);			}		else if (PLL2CLOCK == 166)			{	        audio_clock->AudClkC = 0x0000111E;//166/7/2 =11.85Mhz	        AIU_SET_LRCLOCK_LEN(0x85);			}	#else		audio_clock->PLL3Cfg = 0x0077107F;//MCLK ==11.289Mhz		audio_clock->AudClkC = 0x00001070;			AIU_SET_LRCLOCK_LEN(0xFF);	#endif	}	else if((sRate >= 46000) && (sRate < 64000))	// Set 48kHz status	{		_setRegister2(0x04,0x00);	#if AUDIO_DAC_USING_PLL2		if 		(PLL2CLOCK == 120)			{	        audio_clock->AudClkC = 0x0000111C;//120/5/2 = 12Mhz	        AIU_SET_LRCLOCK_LEN(0x7C);   					}		else if (PLL2CLOCK == 138)			{	        audio_clock->AudClkC = 0x0000111D;//138/6/2 = 11.5Mhz	        AIU_SET_LRCLOCK_LEN(0x77); 					}		else if (PLL2CLOCK == 144)			{	        audio_clock->AudClkC = 0x0000111D;//144/6/2 = 12Mhz	        AIU_SET_LRCLOCK_LEN(0x7C);   					}		else if (PLL2CLOCK == 153)			{	        audio_clock->AudClkC = 0x0000111D;//153/6/2 = 12.75Mhz	        AIU_SET_LRCLOCK_LEN(0x84);			}		else if (PLL2CLOCK == 160)			{	        audio_clock->AudClkC = 0x0000111E;//160/7/2 =11.43Mhz	        AIU_SET_LRCLOCK_LEN(0x76);			}		else if (PLL2CLOCK == 166)			{	        audio_clock->AudClkC = 0x0000111E;//166/7/2 =11.85Mhz	        AIU_SET_LRCLOCK_LEN(0x7B);			}	#else			audio_clock->PLL3Cfg = 0x007718cc;//MCLK ==12.288Mhz		audio_clock->AudClkC = 0x00001070;				AIU_SET_LRCLOCK_LEN(0xFF);	#endif		}	else	{		not_supported_samplerate:			if (AUDIO_DAC_USING_PLL2)			{				MP_ALERT("WM8960 doesn't support PLL2 %d; Only supports PLL2: 120, 138, 144, 153, 160, 166.", PLL2CLOCK);			}		MP_ALERT("Samplerate %d is not supported by IIS.(8K--48K support)", sRate);	}	// If you want to change PLL value, follow below steps	// 1. setting PLL config.	// 2. Disable PLL (ClkCtrl , Clkss_EXT1)	// 3. Re-enable PLL(ClkCtrl , Clkss_EXT1)	#if AUDIO_DAC_USING_PLL2    g_psClock->Clkss_EXT1 &= 0xfffffff0;	#else	g_psClock->Clkss_EXT1 &= 0xfffffff0;	g_psClock->Clkss_EXT1 |= (BIT3);    // Using PLL3/1 to be clock source//	g_psClock->ClkCtrl &= ~0x01000000;		// disable PLL3	g_psClock->ClkCtrl |= 0x01000000;		// enable PLL3	#endif	AIUCLOCK_DISABLE();	AIU_MAINCLOCK_ENABLE();}// Setting AIU registers and reset sample rate int  WM8960_PlayConfig(DWORD sampleRate){	// Mater clock and bit clock setting (If speed is not fast enough, hw i2c will fail.)	g_psClock->PLL3Cfg = 0x0077ffc3;	g_psClock->AudClkC = 0x00001110;	g_psClock->Clkss_EXT1 &= 0xfffffff0;	g_psClock->Clkss_EXT1 |= (BIT3);	 // Using PLL3/1 to be clock source	g_psClock->ClkCtrl &= ~0x01000000;	 // Disable PLL3//	g_psClock->ClkCtrl |= 0x01000000;    // enable PLL3#if (WM8960_USINGHWI2C == ENABLE)	I2CM_FreqChg(WM8960_DEVICE_ADDRESS << 1, 300000);	// Set correct I2C frequency for enabing I2C setting#else	WM8960_GPIO_Init();#endif	AIU_PLAYBACK_GAI_INIT();	AIU_SET_GENERAL_WAVEFORM();		WM8960_SetDACSampleRate(sampleRate);#if (WM8960_USINGHWI2C == DISABLE && IICM_PIN_USING_VGPIO) 		g_psGpio->Vgpcfg1 = gpcfg1;	g_psGpio->Vgpdat1 = gpdat1;#else if (WM8960_USINGHWI2C == DISABLE && !IICM_PIN_USING_VGPIO)	g_psGpio->Gpcfg0  = gpcfg1; 	//set gp0~1 as default function	g_psGpio->Gpdat0  = gpdat1; 	//Output		#endif		return PASS;}/** *************************************************************** * * Config WM8960 clock and gpio * *  Input  : none. * *  Output : none.  ****************************************************************/  void WM8960_AIUCfg(void){		g_psClock->PLL3Cfg = 0x007718CC;		g_psClock->AudClkC = 0x00001570;		g_psClock->Clkss_EXT1 &= 0xfffffff0;		g_psClock->Clkss_EXT1 |= (BIT3);	 // Using PLL3/1 to be clock source		g_psClock->Clkss_EXT2 |= 0x00040000;	//Using since mp650 series		g_psClock->ClkCtrl &= ~0x01000000;	 // Disable PLL3		g_psClock->ClkCtrl |= 0x01000000;	 // enable PLL3				// Select External Bit_Clock Source		AIUCLOCK_DISABLE();		AIU_MAINCLOCK_ENABLE();					// Disable AIU_DMA		g_psDmaAiu->Control = 0x00000000;				// Configure AGPIO to AUDIO Mode		g_psGpio->Agpcfg = 0x0000001F;	#if (WM8960_USINGHWI2C == ENABLE)		I2CM_FreqChg(WM8960_DEVICE_ADDRESS << 1, 300000);#else		WM8960_GPIO_Init();#endif}int WM8960_uninit(){	//mpDebugPrint("Uninit 8961");	WM8960_GPIO_Init();	_setRegister2(0x0f, 0x0000);#if (WM8960_USINGHWI2C == DISABLE && IICM_PIN_USING_VGPIO) 		g_psGpio->Vgpcfg1 = gpcfg1;	g_psGpio->Vgpdat1 = gpdat1;#else if (WM8960_USINGHWI2C == DISABLE && !IICM_PIN_USING_VGPIO)	g_psGpio->Gpcfg0  = gpcfg1;		//set gp0~1 as default function	g_psGpio->Gpdat0  = gpdat1;		//Output		#endif				return PASS;}int AudioInit_WM8960(void){	mpDebugPrint("Audio dec init...WM8960");	register INTERRUPT *interrupt;	WM8960_AIUCfg();#if 1	//Power managment	_setRegister2(0x0f, 0x0000);	_setRegister2(0x1C,0x094);	_setRegister2(0x1D,0x040);	TimerDelay(400);		_setRegister2(0x1A,0x078);	_setRegister2(0x1D,0x000);	_setRegister2(0x19,0x080);	TimerDelay(100);	_setRegister2(0x19,0x0C0);	_setRegister2(0x1C,0x001);	_setRegister2(0x1A,0x1F8);	_setRegister2(0x2F,0x00C);	_setRegister2(0x22,0x150);	_setRegister2(0x25,0x150);	_setRegister2(0x28,0x079);	_setRegister2(0x29,0x179);		_setRegister2(0x31,0x0F7);		_setRegister2(0x05,0x000);	_setRegister2(0x07,0x000);	//Headphone detect	_setRegister2(0x18,0x040);	_setRegister2(0x1B,0x008);	_setRegister2(0x17,0x001);	_setRegister2(0x30,0x00C);#else			//Power managment	_setRegister2(0x0f, 0x0000);	_setRegister2(0x19,0x0C0);	_setRegister2(0x1A,0x1F8);	_setRegister2(0x31,0x0F7);	//Clocking	_setRegister2(0x04,0x030);	_setRegister2(0x08,0x1C0);	//Audio interface	_setRegister2(0x07,0x000);	_setRegister2(0x09,0x000);	//ADC & DAC control	_setRegister2(0x05,0x000);	_setRegister2(0x06,0x00C);		//ROUT & LOUT volume		_setRegister2(0x02,0x165);	_setRegister2(0x03,0x165);	_setRegister2(0x28,0x079);	_setRegister2(0x29,0x179);		//Left & Right MIX	_setRegister2(0x22,0x150);	_setRegister2(0x25,0x150);		//Power Managment	_setRegister2(0x2F,0x00C);	_setRegister2(0x1C,0x000);	//Headphone detect	_setRegister2(0x18,0x040);	_setRegister2(0x1B,0x008);	_setRegister2(0x17,0x001);	_setRegister2(0x30,0x00C);	#endif#if (WM8960_USINGHWI2C == DISABLE && IICM_PIN_USING_VGPIO) 		g_psGpio->Vgpcfg1 = gpcfg1;	g_psGpio->Vgpdat1 = gpdat1;#else if (WM8960_USINGHWI2C == DISABLE && !IICM_PIN_USING_VGPIO)	g_psGpio->Gpcfg0  = gpcfg1;		//set gp0~1 as default function	g_psGpio->Gpdat0  = gpdat1;		//Output		#endif		return PASS;	}int AudioInitRec_WM8960(void){	mpDebugPrint("Audio Rec init...WM8960");	register INTERRUPT *interrupt;	WM8960_AIUCfg();	//_setRegister2(0x0f, 0x0000);	_setRegister2(0x19,0x0FE);		//_setRegister2(0x1A,0x000);//only input	_setRegister2(0x1A,0x1F8);//Output and input at the same time	//Clocking	_setRegister2(0x04,0x1B0);	_setRegister2(0x08,0x1C0);	//Audio interface	_setRegister2(0x07,0x00);	_setRegister2(0x09,0x00);	//ADC & DAC control	_setRegister2(0x05,0x00);	_setRegister2(0x06,0x0C);	//RInput & LInput volume	_setRegister2(0x15,0x1AF);	_setRegister2(0x16,0x1AF);	//ADCL ADCR signal path	_setRegister2(0x20,0x048);	_setRegister2(0x21,0x048);		//Input Boot Mixer	_setRegister2(0x2B,0x00A);	_setRegister2(0x2C,0x00A);	_setRegister2(0x1B,0x005);	//Bypass	_setRegister2(0x2D,0x80);	_setRegister2(0x2E,0x80);	//Power Managment	_setRegister2(0x2F,0x3C); //output and input at the same time	//_setRegister2(0x2F,0x30); //Only input	_setRegister2(0x30,0x0F);	//ALC control 1	_setRegister2(0x11,0x06A);	//ALC control 2	_setRegister2(0x12,0x103);	//Right input & Left input volume	_setRegister2(0x00,0x67);	_setRegister2(0x01,0x67);#if (WM8960_USINGHWI2C == DISABLE && IICM_PIN_USING_VGPIO) 		g_psGpio->Vgpcfg1 = gpcfg1;	g_psGpio->Vgpdat1 = gpdat1;#else if (WM8960_USINGHWI2C == DISABLE && !IICM_PIN_USING_VGPIO)	g_psGpio->Gpcfg0  = gpcfg1; 	//set gp0~1 as default function	g_psGpio->Gpdat0  = gpdat1; 	//Output		#endif		return PASS;}HAL_AUDIODAC_T _audioDAC_WM8960 ={	AudioInit_WM8960,	AudioInitRec_WM8960,	WM8960_uninit,	WM8960_PlayConfig,	NULL,	WM8960_ChgVolume};#endif