/*** FileName     AudioDac_ES8328.c** Author       Eddy* Date         2011.08.02** Description  Driver for CODEC ES8328* */ #define LOCAL_DEBUG_ENABLE 0/*// Include section */#include "global612.h"#include "mpTrace.h"#include "audio_hal.h"#if (AUDIO_DAC == DAC_ES8328) #define es8328_LPPB      0x43#define es8328_NUM_REG   0x44#define es8328_SYSCLK   0#define es8328_CACHE_REGNUM  52#define ES8328_LINVOL    0x00#define ES8328_RINVOL    0x01#define ES8328_LOUT1V    46#define ES8328_ROUT1V    47#define ES8328_ADCDAC    0x05  #define ES8328_SRATE     24  #define ES8328_LDAC      26#define ES8328_RDAC      27#define ES8328_BASS      0x0c#define ES8328_TREBLE    0x0d#define ES8328_RESET     0#define ES8328_3D        0x10#define ES8328_ALC1      0x11#define ES8328_ALC2      0x12#define ES8328_ALC3      0x13#define ES8328_NGATE     0x14#define ES8328_LADC      16         /*Left ADC volume*/#define ES8328_RADC      17         /*Right ADC volume*/#define ES8328_ADCTL1    0x17       /*Additional control(1)*/#define ES8328_ADCTL2    0x18       /*Additional control(2)*/#define ES8328_PWR1      3      /*Pwr Mgmt(1)*/#define ES8328_PWR2      4      /*Pwr Mgmt(2)*/#define ES8328_ADCTL3    0x1b#define ES8328_ADCIN     0x1f       /*ADC input Mode*/#define ES8328_LADCIN    0x20       /*ADCL signal path*/#define ES8328_RADCIN    0x21       /*ADCR signal path*/#define ES8328_LOUTM1    0x22#define ES8328_LOUTM2    0x23#define ES8328_ROUTM1    0x24#define ES8328_ROUTM2    0x25#define ES8328_MOUTM1    0x26#define ES8328_MOUTM2    0x27#define ES8328_LOUT2V    48#define ES8328_ROUT2V    49#define ES8328_MOUTV     50#define ES8328_HPOUT     51#define ES8328_SPKOUT    52/* ES8328 register space */#define ES8328_CONTROL1         0x00#define ES8328_CONTROL2         0x01#define ES8328_CHIPPOWER        0x02#define ES8328_ADCPOWER         0x03#define ES8328_DACPOWER         0x04#define ES8328_CHIPLOPOW1       0x05#define ES8328_CHIPLOPOW2       0x06#define ES8328_ANAVOLMANAG      0x07#define ES8328_MASTERMODE       0x08#define ES8328_ADCCONTROL1      0x09#define ES8328_ADCCONTROL2      0x0a#define ES8328_ADCCONTROL3      0x0b#define ES8328_ADCCONTROL4      0x0c#define ES8328_ADCCONTROL5      0x0d#define ES8328_ADCCONTROL6      0x0e#define ES8328_ADCCONTROL7      0x0f#define ES8328_ADCCONTROL8      0x10#define ES8328_ADCCONTROL9      0x11#define ES8328_ADCCONTROL10     0x12#define ES8328_ADCCONTROL11     0x13#define ES8328_ADCCONTROL12     0x14#define ES8328_ADCCONTROL13     0x15#define ES8328_ADCCONTROL14     0x16#define ES8328_DACCONTROL1      0x17#define ES8328_DACCONTROL2      0x18#define ES8328_DACCONTROL3      0x19#define ES8328_DACCONTROL4      0x1a#define ES8328_DACCONTROL5      0x1b#define ES8328_DACCONTROL6      0x1c#define ES8328_DACCONTROL7      0x1d#define ES8328_DACCONTROL8      0x1e#define ES8328_DACCONTROL9      0x1f#define ES8328_DACCONTROL10     0x20#define ES8328_DACCONTROL11     0x21#define ES8328_DACCONTROL12     0x22#define ES8328_DACCONTROL13     0x23#define ES8328_DACCONTROL14     0x24#define ES8328_DACCONTROL15     0x25#define ES8328_DACCONTROL16     0x26#define ES8328_DACCONTROL17     0x27#define ES8328_DACCONTROL18     0x28#define ES8328_DACCONTROL19     0x29#define ES8328_DACCONTROL20     0x2a#define ES8328_DACCONTROL21     0x2b#define ES8328_DACCONTROL22     0x2c#define ES8328_DACCONTROL23     0x2d#define ES8328_DACCONTROL24     0x2e#define ES8328_DACCONTROL25     0x2f#define ES8328_DACCONTROL26     0x30#define ES8328_DACCONTROL27     0x31#define ES8328_DACCONTROL28     0x32#define ES8328_DACCONTROL29     0x33#define ES8328_DACCONTROL30     0x34#define ES8328_LADC_VOL         ES8328_ADCCONTROL8#define ES8328_RADC_VOL         ES8328_ADCCONTROL9#define ES8328_LDAC_VOL         ES8328_DACCONTROL4#define ES8328_RDAC_VOL         ES8328_DACCONTROL5#define ES8328_LOUT1_VOL        ES8328_DACCONTROL24#define ES8328_ROUT1_VOL        ES8328_DACCONTROL25#define ES8328_LOUT2_VOL        ES8328_DACCONTROL26#define ES8328_ROUT2_VOL        ES8328_DACCONTROL27#define ES8328_ADC_MUTE         ES8328_ADCCONTROL7#define ES8328_DAC_MUTE         ES8328_DACCONTROL3#define ES8328_IFACE            ES8328_MASTERMODE#define ES8328_ADC_IFACE        ES8328_ADCCONTROL4#define ES8328_ADC_SRATE        ES8328_ADCCONTROL5#define ES8328_DAC_IFACE        ES8328_DACCONTROL1#define ES8328_DAC_SRATE        ES8328_DACCONTROL2#define ES8328_CACHEREGNUM      53#define ES8328_SYSCLK           0struct es8328_setup_data {    int i2c_bus;        unsigned short i2c_address;};#if 1 //lzcx#define ES8328_PLL1         0#define ES8328_PLL2         1/* clock inputs */#define ES8328_MCLK     0#define ES8328_PCMCLK       1/* clock divider id's */#define ES8328_PCMDIV       0#define ES8328_BCLKDIV      1#define ES8328_VXCLKDIV     2/* PCM clock dividers */#define ES8328_PCM_DIV_1    (0 << 6)#define ES8328_PCM_DIV_3    (2 << 6)#define ES8328_PCM_DIV_5_5  (3 << 6)#define ES8328_PCM_DIV_2    (4 << 6)#define ES8328_PCM_DIV_4    (5 << 6)#define ES8328_PCM_DIV_6    (6 << 6)#define ES8328_PCM_DIV_8    (7 << 6)/* BCLK clock dividers */#define ES8328_BCLK_DIV_1   (0 << 7)#define ES8328_BCLK_DIV_2   (1 << 7)#define ES8328_BCLK_DIV_4   (2 << 7)#define ES8328_BCLK_DIV_8   (3 << 7)/* VXCLK clock dividers */#define ES8328_VXCLK_DIV_1  (0 << 6)#define ES8328_VXCLK_DIV_2  (1 << 6)#define ES8328_VXCLK_DIV_4  (2 << 6)#define ES8328_VXCLK_DIV_8  (3 << 6)#define ES8328_VXCLK_DIV_16 (4 << 6)#define ES8328_DAI_HIFI     0#define ES8328_DAI_VOICE        1#define ES8328_1536FS 1536#define ES8328_1024FS   1024#define ES8328_768FS    768#define ES8328_512FS    512#define ES8328_384FS    384#define ES8328_256FS    256#define ES8328_128FS    128#endif#if 1       // Software I2C#define CODEC_ES8328_DEVICE_ADDRESS (0x22>>1)#define IIC_FLAG_NO_ACK     1#define IIC_FLAG_ACK        2#define IIC_FLAG_START      3#define IIC_FLAG_STOP       4#define IIC_FLAG_IGNORE     5#define WAIT_TIME_IIC_DELAY 10#define WAIT_TIME_WAIT_ACK  50//--------------------------------------------------------static BYTE ACK1=1, ACK2=1, ACK3=1, ACK4=1;//////////////////////////////////////////// software simulate i2c base//////////////////////////////////////////#define __codec_es8328_i2c_data_high()      (g_psGpio->Gpdat0 |= 0x00000002)#define __codec_es8328_i2c_data_low()           (g_psGpio->Gpdat0 &= 0xfffffffd)#define __codec_es8328_i2c_data_output()        (g_psGpio->Gpdat0 |= 0x00020000)#define __codec_es8328_i2c_data_input()     (g_psGpio->Gpdat0 &= 0xfffdffff)#define __codec_es8328_i2c_clk_high()           (g_psGpio->Gpdat0 |= 0x00000001)#define __codec_es8328_i2c_clk_low()            (g_psGpio->Gpdat0 &= 0xfffffffe)#define __codec_es8328_i2c_clk_output()     (g_psGpio->Gpdat0 |= 0x00010000)#define __codec_es8328_i2c_clk_input()      (g_psGpio->Gpdat0 &= 0xfffeffff)#define __codec_es8328_i2c_read_data()      ((g_psGpio->Gpdat0 & 0x00000002)>>1)#define __codec_es8328_i2c_all_output()     (g_psGpio->Gpdat0 |= 0x00030000)#define __codec_es8328_i2c_set_gpio_mode()  (g_psGpio->Gpcfg0 = (g_psGpio->Gpcfg0 & 0xfffcfffc))static void codec_es8328_i2c_data_high(void){    __codec_es8328_i2c_data_high();     IODelay(WAIT_TIME_IIC_DELAY);}static void codec_es8328_i2c_data_low(void){    __codec_es8328_i2c_data_low();      IODelay(WAIT_TIME_IIC_DELAY);}static void codec_es8328_i2c_data_output(void){    __codec_es8328_i2c_data_output();       IODelay(WAIT_TIME_IIC_DELAY);}static void codec_es8328_i2c_data_input(void){    __codec_es8328_i2c_data_input();        IODelay(WAIT_TIME_IIC_DELAY);}static void codec_es8328_i2c_clk_high(void){    __codec_es8328_i2c_clk_high();      IODelay(WAIT_TIME_IIC_DELAY);}static void codec_es8328_i2c_clk_low(void){    __codec_es8328_i2c_clk_low();           IODelay(WAIT_TIME_IIC_DELAY);}static void codec_es8328_i2c_clk_output(void){    __codec_es8328_i2c_clk_output();        IODelay(WAIT_TIME_IIC_DELAY);}static void codec_es8328_i2c_clk_input(void){    __codec_es8328_i2c_clk_input();     IODelay(WAIT_TIME_IIC_DELAY);}void codec_es8328_GPIO_Init(){    __codec_es8328_i2c_set_gpio_mode();    __codec_es8328_i2c_all_output();}static BYTE SW_codec_es8328_IIC_SetValue(BYTE data1, BYTE condition){    BYTE mask;    BYTE ret;        __codec_es8328_i2c_set_gpio_mode(); // set to GPIO function mode    __codec_es8328_i2c_all_output();        // GP0, GP1 output    if(condition == IIC_FLAG_START)    {        codec_es8328_i2c_clk_high();        codec_es8328_i2c_data_high();        codec_es8328_i2c_data_low();        codec_es8328_i2c_clk_low();    }    codec_es8328_i2c_clk_low();    mask = 0x80;    while(mask > 0)    {        if((mask & data1) == mask)            codec_es8328_i2c_data_high();        else             codec_es8328_i2c_data_low();        codec_es8328_i2c_clk_high();        codec_es8328_i2c_clk_low();        mask >>= 1;    }        //codec_es8328_i2c_data_high();    __codec_es8328_i2c_data_input();        // data = input direction    IODelay(WAIT_TIME_WAIT_ACK);   //    codec_es8328_i2c_clk_high();    //IODelay(40);  //    //IODelay(60);    if(__codec_es8328_i2c_read_data())    {        char tmpbuf[64];        UartOutText("I2C ACK error,");        sprintf(tmpbuf,"data=0x%02x,condition=%d \r\n",data1,condition);        UartOutText(tmpbuf);        //__asm("break 100");        ret = IIC_FLAG_NO_ACK;    }    else    {        //UartOutText("A");        __codec_es8328_i2c_all_output();        // GP0, GP1 output        ret = IIC_FLAG_ACK;        //__codec_es8328_i2c_all_output();  // GP0, GP1 output    }            codec_es8328_i2c_clk_low();    codec_es8328_i2c_data_low();    IODelay(WAIT_TIME_WAIT_ACK);   //    if(condition == IIC_FLAG_STOP){        codec_es8328_i2c_clk_high();        codec_es8328_i2c_data_high();    }    return ret; //IIC_ACK;}static BYTE SW_codec_es8328_IIC_GetValue_NoStop()       // get value, but no stop bit{    BYTE data, i;        __codec_es8328_i2c_set_gpio_mode(); //set to GPIO function mode    __codec_es8328_i2c_data_input();        // DATA = input    __codec_es8328_i2c_clk_output();        // CLK = output    codec_es8328_i2c_clk_low();    data = 0;    for(i = 0; i < 8; i++){        data <<= 1;        //codec_es8328_i2c_clk_low();        codec_es8328_i2c_clk_high();        data |= __codec_es8328_i2c_read_data();        codec_es8328_i2c_clk_low();    }    // ACK    codec_es8328_i2c_clk_low();    IODelay(WAIT_TIME_WAIT_ACK);    __codec_es8328_i2c_all_output();        // GP0, GP1 output    //codec_es8328_i2c_data_low(); // ACK        codec_es8328_i2c_data_low(); // ACK        codec_es8328_i2c_clk_high();    codec_es8328_i2c_clk_low();    IODelay(WAIT_TIME_WAIT_ACK);    return data;}static BYTE SW_codec_es8328_IIC_GetValue(){    BYTE data, i;        __codec_es8328_i2c_set_gpio_mode(); //set to GPIO function mode    __codec_es8328_i2c_data_input();  // DATA = input    __codec_es8328_i2c_clk_output();  // CLK = output    codec_es8328_i2c_clk_low();    data = 0;    for(i = 0; i < 8; i++){        data <<= 1;               // codec_es8328_i2c_clk_low();        codec_es8328_i2c_clk_high();        data |= __codec_es8328_i2c_read_data();        codec_es8328_i2c_clk_low();         }    // ACK    codec_es8328_i2c_clk_low();    IODelay(WAIT_TIME_WAIT_ACK);    __codec_es8328_i2c_all_output();  // GP0, GP1 output    //codec_es8328_i2c_data_low(); // ACK        codec_es8328_i2c_data_high(); // ACK        codec_es8328_i2c_clk_high();        //__codec_es8328_i2c_data_input();  // GP1 = input        // end    codec_es8328_i2c_clk_low();    codec_es8328_i2c_data_low();    IODelay(WAIT_TIME_WAIT_ACK);    codec_es8328_i2c_clk_high();    codec_es8328_i2c_data_high();        return data;}static BYTE ES8328_setRegister(BYTE addr, BYTE data){    ACK1 = SW_codec_es8328_IIC_SetValue(CODEC_ES8328_DEVICE_ADDRESS<<1, IIC_FLAG_START);     ACK2 = SW_codec_es8328_IIC_SetValue(addr, IIC_FLAG_IGNORE);    ACK3 = SW_codec_es8328_IIC_SetValue(data, IIC_FLAG_STOP);}static BYTE ES8328_gettRegister(BYTE addr){    BYTE value1 = 0;    ACK1 = SW_codec_es8328_IIC_SetValue(CODEC_ES8328_DEVICE_ADDRESS<<1, IIC_FLAG_START);    ACK2 = SW_codec_es8328_IIC_SetValue((addr>>8)&0xff, IIC_FLAG_IGNORE);    ACK2 = SW_codec_es8328_IIC_SetValue(addr&0xff, IIC_FLAG_IGNORE);    __codec_es8328_i2c_data_high();    ACK3 = SW_codec_es8328_IIC_SetValue((CODEC_ES8328_DEVICE_ADDRESS<<1) | 0x01, IIC_FLAG_START);    value1 = SW_codec_es8328_IIC_GetValue();    return value1;}#endif///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////static DWORD gpcfg1;static DWORD gpdat1;void ES8328_GPIO_Init(){    //mpDebugPrint("ES8328_GPIO_Init");}void ES8328_Reset(){    ES8328_setRegister(0x00, 0x80);    ES8328_setRegister(0x00, 0x00);}/* *    Mapping 16 level of UI volune value to 128 level hardware value */void ES8328_ChgVolume(WORD vol){    //mpDebugPrint("ES8328 volume level: %d", vol);}void ES8328_SetDACSampleRate(DWORD sRate){    register CLOCK *audio_clock;    int data;    audio_clock = (CLOCK *) (CLOCK_BASE);    audio_clock->PLL3Cfg = 0x00770107;    int PLL2CLOCK = (Clock_PllFreqGet(CLOCK_PLL2_INDEX)/1000000);        if (AUDIO_DAC_USING_PLL2)        mpDebugPrint("ES8328 using PLL2 Clock Freq.: %d", PLL2CLOCK);    else        mpDebugPrint("ES8328 using PLL3");        mpDebugPrint("ES8328 Samplerate: %d", sRate);        if ((sRate > 7000)  && (sRate < 11000)) // Set 8kHz status    {       #if AUDIO_DAC_USING_PLL2        if (PLL2CLOCK == 120)        {            audio_clock->AudClkC = 0x000013BC;//120/5/12 = 2Mhz(MCLK)            AIU_SET_LRCLOCK_LEN(0x3F);      // lrclk set as 7.8125khz   2000kHz/4/64 = 7.8125khz        }        else if (PLL2CLOCK == 132)        {            audio_clock->AudClkC = 0x000013CC;//138/5/13 = 2.03Mhz(MCLK)            AIU_SET_LRCLOCK_LEN(0x3F);      // lrclk set as 7.9326khz           }        else if (PLL2CLOCK == 138)        {            audio_clock->AudClkC = 0x000013AD;//138/6/11 = 2.09Mhz(MCLK)            AIU_SET_LRCLOCK_LEN(0x3F);      // lrclk set as 8.16khz         }        else if (PLL2CLOCK == 144)        {            audio_clock->AudClkC = 0x000013BD;//144/6/12 = 2Mhz(MCLK)            AIU_SET_LRCLOCK_LEN(0x3F);      // lrclk set as 7.8khz          }        else if (PLL2CLOCK == 150)        {            audio_clock->AudClkC = 0x000013BD;//150/5/12 = 2.083Mhz(MCLK); 8kb/1008ms            AIU_SET_LRCLOCK_LEN(0x3F);      // lrclk set as 8.138khz            }        else if (PLL2CLOCK == 153)        {            audio_clock->AudClkC = 0x000013EC;//153/5/15 = 2.04Mhz(MCLK); 8kb/1028ms            AIU_SET_LRCLOCK_LEN(0x3F);      // lrclk set as 7.968khz                //audio_clock->AudClkC = 0x000013BD;//153/6/12 = 2.125Mhz(MCLK); 8kb/988ms            //AIU_SET_LRCLOCK_LEN(0x3F);        // lrclk set as 8.3khz          }        else            mpDebugPrint("IIS not support this PLL2 frequency");    #else        audio_clock->PLL3Cfg = 0x007761FA;        audio_clock->AudClkC = 0x000013E0;        AIU_SET_LRCLOCK_LEN(0x3F);  // lrclk set as 8.003khz, it works; 8kb/1024ms    #endif      }    else if((sRate >= 11000) && (sRate < 11300))    // Set 11.025kHz status    {       #if AUDIO_DAC_USING_PLL2        if      (PLL2CLOCK == 120)            {            audio_clock->AudClkC = 0x0000141C;//120/5/2 = 12Mhz            AIU_SET_LRCLOCK_LEN(0xD9);                      }        else if (PLL2CLOCK == 138)            {            audio_clock->AudClkC = 0x0000141D;//138/6/2 = 11.5Mhz            AIU_SET_LRCLOCK_LEN(0xD0);              }        else if (PLL2CLOCK == 144)            {            audio_clock->AudClkC = 0x0000141D;//144/6/2 = 12Mhz            AIU_SET_LRCLOCK_LEN(0xD9);                      }        else if (PLL2CLOCK == 153)            {            audio_clock->AudClkC = 0x0000141D;//153/6/2 = 12.75Mhz            AIU_SET_LRCLOCK_LEN(0xE7);             }        else            mpDebugPrint("IIS not support this PLL2 frequency");    #else           audio_clock->PLL3Cfg = 0x0077107F;        audio_clock->AudClkC = 0x00001370;          AIU_SET_LRCLOCK_LEN(0xFF);    #endif      }    else if((sRate >= 11300) && (sRate < 14000))    // Set 12kHz status    {    #if AUDIO_DAC_USING_PLL2        if      (PLL2CLOCK == 120)            {            audio_clock->AudClkC = 0x0000131C;//120/5/2 = 12Mhz            AIU_SET_LRCLOCK_LEN(0xFF);                      }        else if (PLL2CLOCK == 138)            {            audio_clock->AudClkC = 0x0000131D;//138/6/2 = 11.5Mhz            AIU_SET_LRCLOCK_LEN(0xEF);                          }        else if (PLL2CLOCK == 144)            {            audio_clock->AudClkC = 0x0000131D;//144/6/2 = 12Mhz            AIU_SET_LRCLOCK_LEN(0xFF);                      }        else if (PLL2CLOCK == 153)            {            audio_clock->AudClkC = 0x0000141D;//153/6/2 = 12.75Mhz            AIU_SET_LRCLOCK_LEN(0xD4);             }        else            mpDebugPrint("IIS not support this PLL2 frequency");    #else        audio_clock->PLL3Cfg = 0x007718cc;        audio_clock->AudClkC = 0x00001370;        AIU_SET_LRCLOCK_LEN(0xFF);          #endif      }    else if((sRate >= 14000) && (sRate < 22000))    // Set 16kHz status    {    #if AUDIO_DAC_USING_PLL2        if      (PLL2CLOCK == 120)            {            audio_clock->AudClkC = 0x0000121C;//120/5/2 = 12Mhz            AIU_SET_LRCLOCK_LEN(0xFA);                      }        else if (PLL2CLOCK == 138)            {            audio_clock->AudClkC = 0x0000121D;//138/6/2 = 11.5Mhz            AIU_SET_LRCLOCK_LEN(0xEF);                  }        else if (PLL2CLOCK == 144)            {            audio_clock->AudClkC = 0x0000121D;//144/6/2 = 12Mhz            AIU_SET_LRCLOCK_LEN(0xFA);                      }        else if (PLL2CLOCK == 153)            {            audio_clock->AudClkC = 0x0000131D;//153/6/2 = 12.75Mhz            AIU_SET_LRCLOCK_LEN(0xC7);            }        else            mpDebugPrint("IIS not support this PLL2 frequency");    #else        audio_clock->PLL3Cfg = 0x007718cc;        audio_clock->AudClkC = 0x00001270;          AIU_SET_LRCLOCK_LEN(0xFF);          #endif      }    else if((sRate >= 20000) && (sRate < 23000))    // Set 22.05Hz status    {    #if AUDIO_DAC_USING_PLL2        if      (PLL2CLOCK == 120)            {            audio_clock->AudClkC = 0x0000131C;//120/5/2 = 12Mhz            AIU_SET_LRCLOCK_LEN(0x88);                      }        else if (PLL2CLOCK == 138)            {            audio_clock->AudClkC = 0x0000131D;//138/6/2 = 11.5Mhz            AIU_SET_LRCLOCK_LEN(0x82);                      }        else if (PLL2CLOCK == 144)            {            audio_clock->AudClkC = 0x0000131D;//144/6/2 = 12Mhz            AIU_SET_LRCLOCK_LEN(0x88);                      }        else if (PLL2CLOCK == 153)            {            audio_clock->AudClkC = 0x0000141D;//153/6/2 = 12.75Mhz            AIU_SET_LRCLOCK_LEN(0x73);            }        else            mpDebugPrint("IIS not support this PLL2 frequency");    #else        audio_clock->PLL3Cfg = 0x0077107F;//MCLK ==11.289Mhz        audio_clock->AudClkC = 0x00001170;              AIU_SET_LRCLOCK_LEN(0xFF);    #endif    }    else if((sRate >= 22000) && (sRate < 30000))    // Set 24kHz status    {    #if AUDIO_DAC_USING_PLL2        if      (PLL2CLOCK == 120)            {            audio_clock->AudClkC = 0x0000131C;//120/5/2 = 12Mhz            AIU_SET_LRCLOCK_LEN(0x7C);                  }        else if (PLL2CLOCK == 138)            {            audio_clock->AudClkC = 0x0000131D;//138/6/2 = 11.5Mhz            AIU_SET_LRCLOCK_LEN(0x77);                  }        else if (PLL2CLOCK == 144)            {            audio_clock->AudClkC = 0x0000131D;//144/6/2 = 12Mhz            AIU_SET_LRCLOCK_LEN(0x7C);                      }        else if (PLL2CLOCK == 153)            {            audio_clock->AudClkC = 0x0000141D;//153/6/2 = 12.75Mhz            AIU_SET_LRCLOCK_LEN(0x69);            }        else            mpDebugPrint("IIS not support this PLL2 frequency");    #else           audio_clock->PLL3Cfg = 0x007718cc;        audio_clock->AudClkC = 0x00001170;          AIU_SET_LRCLOCK_LEN(0xFF);    #endif      }    else if((sRate >= 30000) && (sRate < 36000))    // Set 32kHz status    {    #if AUDIO_DAC_USING_PLL2        if      (PLL2CLOCK == 120)            {            audio_clock->AudClkC = 0x0000121C;//120/5/2 = 12Mhz            AIU_SET_LRCLOCK_LEN(0x7C);                  }        else if (PLL2CLOCK == 138)            {            audio_clock->AudClkC = 0x0000121D;//138/6/2 = 11.5Mhz            AIU_SET_LRCLOCK_LEN(0x77);                  }        else if (PLL2CLOCK == 144)            {            audio_clock->AudClkC = 0x0000121D;//144/6/2 = 12Mhz            AIU_SET_LRCLOCK_LEN(0x7C);                      }        else if (PLL2CLOCK == 153)            {            audio_clock->AudClkC = 0x0000121D;//153/6/2 = 12.75Mhz            AIU_SET_LRCLOCK_LEN(0x84);             }        else            mpDebugPrint("IIS not support this PLL2 frequency");    #else           audio_clock->PLL3Cfg = 0x007718cc;        audio_clock->AudClkC = 0x00001270;          AIU_SET_LRCLOCK_LEN(0x7F);    #endif      }    else if((sRate >= 36000) && (sRate < 46000))    // Set 44.1kHz status    {    #if AUDIO_DAC_USING_PLL2        if (PLL2CLOCK == 120)        {            audio_clock->AudClkC = 0x0000111C;//120/5/2 = 12Mhz            AIU_SET_LRCLOCK_LEN(0x85);        }        else if (PLL2CLOCK == 138)        {            audio_clock->AudClkC = 0x0000111D;//138/6/2 = 11.5Mhz            AIU_SET_LRCLOCK_LEN(0x82);        }        else if (PLL2CLOCK == 144)        {            audio_clock->AudClkC = 0x0000111D;//144/6/2 = 12Mhz            AIU_SET_LRCLOCK_LEN(0x87);        }        else if (PLL2CLOCK == 153)        {            audio_clock->AudClkC = 0x0000111D;//153/6/2 = 12.75Mhz            AIU_SET_LRCLOCK_LEN(0x8E);         }        else            mpDebugPrint("IIS not support this PLL2 frequency");    #else        audio_clock->PLL3Cfg = 0x0077107F;//MCLK ==11.289Mhz        audio_clock->AudClkC = 0x00001070;          AIU_SET_LRCLOCK_LEN(0xFF);    #endif    }    else if((sRate >= 46000) && (sRate < 64000))    // Set 48kHz status    {    #if AUDIO_DAC_USING_PLL2        if      (PLL2CLOCK == 120)            {            audio_clock->AudClkC = 0x0000111C;//120/5/2 = 12Mhz            AIU_SET_LRCLOCK_LEN(0x7C);                      }        else if (PLL2CLOCK == 138)            {            audio_clock->AudClkC = 0x0000111D;//138/6/2 = 11.5Mhz            AIU_SET_LRCLOCK_LEN(0x77);                  }        else if (PLL2CLOCK == 144)            {            audio_clock->AudClkC = 0x0000111D;//144/6/2 = 12Mhz            AIU_SET_LRCLOCK_LEN(0x7C);                      }        else if (PLL2CLOCK == 153)            {            audio_clock->AudClkC = 0x0000111D;//153/6/2 = 12.75Mhz            AIU_SET_LRCLOCK_LEN(0x84);            }        else            mpDebugPrint("IIS not support this PLL2 frequency");    #else           audio_clock->PLL3Cfg = 0x007718cc;//MCLK ==12.288Mhz        audio_clock->AudClkC = 0x00001070;              AIU_SET_LRCLOCK_LEN(0xFF);    #endif      }    else        mpDebugPrint("Samplerate %d is not supported by IIS.", sRate);    // If you want to change PLL value, follow below steps    // 1. setting PLL config.    // 2. Disable PLL (ClkCtrl , Clkss_EXT1)    // 3. Re-enable PLL(ClkCtrl , Clkss_EXT1)    #if AUDIO_DAC_USING_PLL2    g_psClock->Clkss_EXT1 &= 0xfffffff0;    #else    g_psClock->Clkss_EXT1 &= 0xfffffff0;    g_psClock->Clkss_EXT1 |= (BIT3);    // Using PLL3/1 to be clock source//  g_psClock->ClkCtrl &= ~0x01000000;      // disable PLL3    g_psClock->ClkCtrl |= 0x01000000;       // enable PLL3    #endif        AIUCLOCK_DISABLE();    AIU_LEFT_JUSTIFIED();    AIU_MAINCLOCK_ENABLE();    MP_DEBUG("ES8328_SetDACSampleRate end");}// Setting AIU registers and reset sample rate int  ES8328_PlayConfig(DWORD sampleRate){    MP_DEBUG("ES8328_PlayConfig");    // Mater clock and bit clock setting (If speed is not fast enough, hw i2c will fail.)    g_psClock->PLL3Cfg = 0x0077ffc3;    g_psClock->AudClkC = 0x00001110;    g_psClock->Clkss_EXT1 &= 0xfffffff0;    g_psClock->Clkss_EXT1 |= (BIT3);     // Using PLL3/1 to be clock source    g_psClock->ClkCtrl &= ~0x01000000;   // Disable PLL3//  g_psClock->ClkCtrl |= 0x01000000;    // enable PLL3    AIU_PLAYBACK_GAI_INIT();    AIU_SET_GENERAL_WAVEFORM();        ES8328_SetDACSampleRate(sampleRate);    return PASS;}/** *************************************************************** * * Config ES8328 clock and gpio * *  Input  : none. * *  Output : none.  ****************************************************************/  void ES8328_AIUCfg(void){    MP_DEBUG("Audio ES8328_AIUCfg");    g_psClock->PLL3Cfg = 0x007718cc;    g_psClock->AudClkC = 0x00001770;    g_psClock->Clkss_EXT1 &= 0xfffffff0;    g_psClock->Clkss_EXT1 |= (BIT3);     // Using PLL3/1 to be clock source    g_psClock->ClkCtrl &= ~0x01000000;   // Disable PLL3    g_psClock->ClkCtrl |= 0x01000000;    // enable PLL3    // Select External Bit_Clock Source    AIUCLOCK_DISABLE();    AIU_SET_BIGENDIAN();    AIU_LEFT_JUSTIFIED();    AIU_SET_16BITMODE();    AIU_MAINCLOCK_ENABLE();        // Disable AIU_DMA    g_psDmaAiu->Control = 0x00000000;            // Configure AGPIO to AUDIO Mode    g_psGpio->Agpcfg = 0x0000001F;    //mpDebugPrint("0 g_psAiu->AiuCtl 0x%.8x",g_psAiu->AiuCtl);    //mpDebugPrint("0 g_psAiu->AiuCtl1 0x%.8x",g_psAiu->AiuCtl1);}int ES8328_uninit(){    mpDebugPrint("uninit ES8328");    return PASS;}static void ES8328_InitRegister(){    ES8328_setRegister(0x08, 0x00);    //ES8328_setRegister(0x2B, 0x80);    ES8328_setRegister(0x2d, 0x00); // vroi=0    ES8328_setRegister(0x02, 0xF3);    TaskSleep(20);    ES8328_setRegister(0x00, 0x05);    ES8328_setRegister(0x01, 0x40);    TaskSleep(20);    ES8328_setRegister(0x03, 0x00);    ES8328_setRegister(0x04, 0x3C);    ES8328_setRegister(0x05, 0x00);    ES8328_setRegister(0x06, 0x00);    ES8328_setRegister(0x07, 0x7C);    ES8328_setRegister(0x0A, 0x00);    ES8328_setRegister(0x09, 0x88);    ES8328_setRegister(0x0C, 0x0d); // Left justify, 16bit    ES8328_setRegister(0x0D, 0x02); // 256fs    ES8328_setRegister(0x10, 0x00);    ES8328_setRegister(0x11, 0x00);       //ES8328_setRegister(0x09, 0x77); // Reg 0x09 = 0x77 (+21Db)    ES8328_setRegister(0x12, 0xe2); // Reg 0x12 = 0xe2 (ALC enable, PGA Max. Gain=23.5dB, Min. Gain=0dB)    ES8328_setRegister(0x13, 0xc0); // Reg 0x13 = 0xc0 (ALC Target=-4.5dB, ALC Hold time =0 mS)    ES8328_setRegister(0x14, 0x12); // Reg 0x14 = 0x12(Decay time =820uS , Attack time = 416 uS)    ES8328_setRegister(0x15, 0x06); // Reg 0x15 = 0x06(ALC mode)    ES8328_setRegister(0x16, 0xc3); // Reg 0x16 = 0xc3(nose gate = -40.5dB, NGG = 0x01(mute ADC))    ES8328_setRegister(0x17, 0x1a); // Left justify, 16bit    ES8328_setRegister(0x18, 0x02); // 256fs        // DAC unmute (automute off)    ES8328_setRegister(0x19, 0x02);       ES8328_setRegister(0x1A, 0x00); //vol    ES8328_setRegister(0x1B, 0x00);    //Setup Mixer    ES8328_setRegister(0x26, 0x00);    ES8328_setRegister(0x27, 0xB8);    ES8328_setRegister(0x28, 0x38);    ES8328_setRegister(0x29, 0x38);    ES8328_setRegister(0x2A, 0xB8);    //Set LOUT/ROUT Volume    ES8328_setRegister(0x2E, 0x1E);    ES8328_setRegister(0x2F, 0x1E);    ES8328_setRegister(0x30, 0x1E);    ES8328_setRegister(0x31, 0x1E);    //Power up DEM and STM    //ES8328_setRegister(0x02, 0x00);       // ADC & DAC}int AudioInit_ES8328(void){    mpDebugPrint("Audio dec init...ES8328");    mpDebugPrint("%s()", __FUNCTION__);    ES8328_AIUCfg();#if 1   // init for codec mode    //ES8328_InitRegister();    //ES8328_Codec_SetPlayMode();#endif    //ES8328_setRegister(codec,0x2D,0x90);  //ROUTINV=1,OUT3=VREF,VROI=1,DISABLE HEADPHONE SWITCH            return PASS;}int AudioInitRec_ES8328(void){    mpDebugPrint("Audio Rec init...ES8328");    mpDebugPrint("%s()", __FUNCTION__);        ES8328_AIUCfg();    MP_DEBUG("Audio rec init ES8328 finished...");    return PASS;}HAL_AUDIODAC_T _audioDAC_ES8328 ={    AudioInit_ES8328,    AudioInitRec_ES8328,    ES8328_uninit,    ES8328_PlayConfig,    NULL,    ES8328_ChgVolume};void ES8328_Codec_SetPlayModeIO(){    g_psGpio->Pgpcfg &= ~0x00080000;    g_psGpio->Pgpcfg |= 0x00000008;    g_psGpio->Pgpdat |= 0x00080000;    g_psGpio->Pgpdat |= 0x00000008;     // High: play state}void ES8328_Codec_SetRecordModeIO(){    g_psGpio->Pgpcfg &= ~0x00080000;    g_psGpio->Pgpcfg |= 0x00000008;    g_psGpio->Pgpdat |= 0x00080000;    g_psGpio->Pgpdat &= ~0x00000008;    // LOw : record state}void ES8328_Codec_SetPlayMode(){    ES8328_Codec_SetPlayModeIO();    //Power up DEM and STM    ES8328_InitRegister();    IODelay(100);    ES8328_setRegister(0x02, 0xAA);}void ES8328_Codec_SetRecordMode(){    ES8328_Codec_SetRecordModeIO();    //Power up DEM and STM    ES8328_InitRegister();    IODelay(100);    ES8328_setRegister(0x02, 0x55);}#endif