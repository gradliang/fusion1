/*************************************************************************                      Magic Pixel Inc.**    Copyright 2004, Magic Pixel Inc., HsinChu, Taiwan*                    All rights reserved.**** Filename:      audioSimInterface.c** Programmer:    C.W Liu*                MPX S270 division** Created: 	 04/30/2010** Description:   Simple audio interface to playback audio data*** Change History (most recent first):*     <1>     04/30/2010    C.W Liu      First file************************************************************************/#define LOCAL_DEBUG_ENABLE 0#include "global612.h"#include "mpTrace.h"#include "wavUtil.h"#include "peripheral.h"#include "audio_hal.h"#include "audio.h"#include "taskid.h"#include "bitsdefine.h"#define hci_len 48#define buf_num 20#define buf_num_playback 20/* note: for BT Hands-Free phone call to work, currently need to enable 'ISR_WAVEOUT_STREAM' */#define ISR_WAVEOUT_STREAM              DISABLE  // MP650¤½ªO modify  /* if using two bufferA and bufferB, and not to stop DMA, please enable it */#define EVENT_WAVE_IN_DATA		BIT0#define STATUS_BUFFER_IDLE 0x3#define STATUS_BUFFER_WORKING 0x1#define buf_size_playback 2048#define AMR_MAGIC_NUMBER "#!AMR\n"struct ST_SIMPLE_AUDIO_MAIL_TAG{	DWORD* buf;	DWORD  len;};typedef struct ST_SIMPLE_AUDIO_MAIL_TAG ST_SIMPLE_AUDIO_MAIL;//Record soundtypedef struct AUDIO_RECORD_BUF{	volatile BYTE buf[2048];	DWORD status; //0x0 : ready 0x1 : recording 0x2 : wait2release. // for ISR}AUDIO_RECORD_BUF;typedef struct AUDIO_PLAYBACK_BUF{	volatile BYTE buf[buf_size_playback];	DWORD len;	DWORD status; //ready: 0x1  playback: 0x3 // for ISR}AUDIO_PLAYBACK_BUF;#if AUDIO_ONAUDIO_RECORD_BUF *audio_record_buf1[buf_num];static int current_num_dma = 0;int soft_irq;int still_record;int buf_size;static int TASK_ENABLE=0;static BYTE write_magic_number;#define buf_size_playback 2048//Playback soundAUDIO_PLAYBACK_BUF *audio_playback_buf[buf_num_playback];static BYTE first=1;static BYTE current_playback=0;static BYTE current_receive=0;static BYTE count_toofast=0;static WORD bufferEnd = 0;//ISRvoid SimAudioISR();void SimAudioISR2();//FunctionSBYTE WaveInputProc();static WORD PCMRecordStart1(unsigned char *buffer, DWORD size);static inline void CleanAllBufferState();typedef DWORD (*AUDIORECORD_CALLBACK_FUNC)(BYTE *record_buf,DWORD buf_len,...);static AUDIORECORD_CALLBACK_FUNC audiorecord_CallBackFunction = NULL;// When Bt aiudio connect success shall initilize audio output module//Parameter 1: sample rate //Parameter 2: channel number//Parameter 3: sample size : 1 bytes or 2 bytes //Parameter 4: big endian : 1 or little endian : 0SBYTE Audio_OpenOutputDevice(WORD srate, BYTE channels, BYTE sampleSize,BYTE bigendian){	int i=0;	#if ( (AUDIO_ON == 1) && (AUDIO_DAC == DAC_WM8904) ) //FGPIO11 is set to run WM8904_InitRecordMode(); by eddy 2012.04.18	//AIU_RIGHT_JUSTIFIED();mpDebugPrint("Audio_CloseInputDevice AIU_RIGHT_JUSTIFIED");	Gpio_Config2GpioFunc(GPIO_FGPIO_10, GPIO_OUTPUT_MODE, GPIO_DATA_HIGH, 1);//to set FGPIO11 must set FGPIO10	Gpio_Config2GpioFunc(GPIO_FGPIO_11, GPIO_OUTPUT_MODE, GPIO_DATA_HIGH, 1);//set FGPIO11 to LOW, for DAC_WM8904	MP_DEBUG("Play mode: WM8904 set GPIO_FGPIO_11: GPIO_OUTPUT_MODE, GPIO_DATA_HIGH");#endif	MX6xx_AudioHW_On();	/* Open audio device */#if ISR_WAVEOUT_STREAM		if (MX6xx_AudioOpen(0) < 0)#else	if (MX6xx_AudioOpen(1) < 0)#endif				return -1;	/* Configure audio device */	//MX6xx_AudioConfig(srate, channels, sampleSize<<3);	MX6xx_AudioConfig(srate, channels, sampleSize<<3);#if (SOFT_RECORD && RECORD_AUDIO)	AIU_LEFT_JUSTIFIED();#endif	if (!bigendian)		AIU_SET_LITTLEENDIAN();	AiuDmaRegCallBackFunc(SimAudioISR);	#if ISR_WAVEOUT_STREAM	for (i=0;i<buf_num_playback;i++)	{		audio_playback_buf[i] = (AUDIO_PLAYBACK_BUF *)mem_malloc(sizeof(AUDIO_PLAYBACK_BUF));		audio_playback_buf[i]->status = STATUS_BUFFER_IDLE;	}	#endif	//Initialize global value	current_playback=0;	current_receive=0;	count_toofast=0;	bufferEnd = 0;    first=1;	return 0;}// When Bt aiudio dis-connect success shall de-initilize audio output moduleSBYTE Audio_CloseOutputDevice(){	int i =0;	MX6xx_AudioClose();	AiuDmaClearCallBackFunc();		//MX6xx_AudioHW_Off();	#if ISR_WAVEOUT_STREAM	for(i=0;i<buf_num_playback;i++)		mem_free(audio_playback_buf[i]);	#endif	return 0;}void Timercallbackfunction(){	int i=14,count=0;	volatile WORD value = 0;	static WORD pre_value;	static int buf_pos=0;	BYTE bitclk=0,record_flag=0,sign=0;    INTERRUPT *isr = (INTERRUPT *) INT_BASE;    TIMER *regTimerPtr = (TIMER *) TIMER3_BASE;#if 1	DWORD Dtick[10], Dtpc[10], Dtmv[10];	DWORD elapsed_time[10], index = 0;//	ST_WORD_BIT_FIELD i2sData;//	get_cur_timeL(&Dtick[0], &Dtpc[0], &Dtmv[0]);	index++;     isr->MiMask &= ~IM_TM3;  //	get_cur_timeL(&(Dtick[index]), &(Dtpc[index]), &(Dtmv[index]));	index++;	while ((g_psGpio->Agpdat & 0x4) == 0);		// LRC = L	while ((g_psGpio->Agpdat & 0x1) == 0);		// bit clk ==0	//	i2sData.bit_item.bBit15 = (g_psGpio->Gpdat0 & 0x80) ? 1 : 0;	value =  (WORD) (((g_psGpio->Gpdat0) & 0x80 )<<8);//	value =  (WORD) (((g_psGpio->Agpdat) & 0x08 )<<15);//	g_psGpio->Gpdat0 |= ((g_psGpio->Gpdat0>>7) & 0x1 )<<3;	while ((g_psGpio->Agpdat & 0x1) == 1);  // bit clk == 1		while ((g_psGpio->Agpdat & 0x1) == 0);  // bit clk == 0//	i2sData.bit_item.bBit14 = (g_psGpio->Gpdat0 & 0x80) ? 1 : 0;	value |= (WORD) (((g_psGpio->Gpdat0) & 0x80 )<<7);//	value |= (WORD) (((g_psGpio->Agpdat) & 0x08 )<<14);//	g_psGpio->Gpdat0 |= ((g_psGpio->Gpdat0>>7) & 0x1 )<<3;	while ((g_psGpio->Agpdat & 0x1) == 1);  // bit clk == 1 	 	while ((g_psGpio->Agpdat & 0x1) == 0);  // bit clk == 0//	i2sData.bit_item.bBit13 = (g_psGpio->Gpdat0 & 0x80) ? 1 : 0;	value |= (WORD) (((g_psGpio->Gpdat0) & 0x80 )<<6);//	value |= (WORD) (((g_psGpio->Agpdat) & 0x08 )<<13);//	g_psGpio->Gpdat0 |= ((g_psGpio->Gpdat0>>7) & 0x1 )<<3;	while ((g_psGpio->Agpdat & 0x1) == 1);		while ((g_psGpio->Agpdat & 0x1) == 0);//	i2sData.bit_item.bBit12 = (g_psGpio->Gpdat0 & 0x80) ? 1 : 0;//	value |= (WORD) (((g_psGpio->Gpdat0>>7) & 0x1 )<<12);	value |= (WORD) (((g_psGpio->Gpdat0) & 0x80 )<<5);//	value |= (WORD) (((g_psGpio->Agpdat) & 0x08 )<<12);//	g_psGpio->Gpdat0 |= ((g_psGpio->Gpdat0>>7) & 0x1 )<<3;	while ((g_psGpio->Agpdat & 0x1) == 1);		while ((g_psGpio->Agpdat & 0x1) == 0);//	i2sData.bit_item.bBit11 = (g_psGpio->Gpdat0 & 0x80) ? 1 : 0;//	value |= (WORD) (((g_psGpio->Gpdat0>>7) & 0x1 )<<11);	value |= (WORD) (((g_psGpio->Gpdat0) & 0x80 )<<4);	while ((g_psGpio->Agpdat & 0x1) == 1);		while ((g_psGpio->Agpdat & 0x1) == 0);//	i2sData.bit_item.bBit10 = (g_psGpio->Gpdat0 & 0x80) ? 1 : 0;//	value |= (WORD) (((g_psGpio->Gpdat0>>7) & 0x1 )<<10);	value |= (WORD) (((g_psGpio->Gpdat0) & 0x80 )<<3);	while ((g_psGpio->Agpdat & 0x1) == 1);		while ((g_psGpio->Agpdat & 0x1) == 0);//	i2sData.bit_item.bBit9 = (g_psGpio->Gpdat0 & 0x80) ? 1 : 0;// 	value |= (WORD) (((g_psGpio->Gpdat0>>7) & 0x1 )<<9);	value |= (WORD) (((g_psGpio->Gpdat0) & 0x80 )<<2);//	value |= (WORD) (((g_psGpio->Agpdat) & 0x08 )<<9);	while ((g_psGpio->Agpdat & 0x1) == 1);		while ((g_psGpio->Agpdat & 0x1) == 0);//	i2sData.bit_item.bBit8 = (g_psGpio->Gpdat0 & 0x80) ? 1 : 0;//	value |= (WORD) (((g_psGpio->Gpdat0>>7) & 0x1 )<<8);	value |= (WORD) (((g_psGpio->Gpdat0) & 0x80 )<<1);//	value |= (WORD) (((g_psGpio->Agpdat) & 0x08 )<<8);	while ((g_psGpio->Agpdat & 0x1) == 1);		while ((g_psGpio->Agpdat & 0x1) == 0);//	i2sData.bit_item.bBit7= (g_psGpio->Gpdat0 & 0x80) ? 1 : 0;//	value |= (WORD) (((g_psGpio->Gpdat0>>7) & 0x1 )<<7);	value |= (WORD) (((g_psGpio->Gpdat0) & 0x80 ));	while ((g_psGpio->Agpdat & 0x1) == 1);		while ((g_psGpio->Agpdat & 0x1) == 0);//	i2sData.bit_item.bBit6 = (g_psGpio->Gpdat0 & 0x80) ? 1 : 0;//	value |= (WORD) (((g_psGpio->Gpdat0>>7) & 0x1 )<<6);	value |= (WORD) (((g_psGpio->Gpdat0) & 0x80 )>>1);	while ((g_psGpio->Agpdat & 0x1) == 1);		while ((g_psGpio->Agpdat & 0x1) == 0);//	i2sData.bit_item.bBit5 = (g_psGpio->Gpdat0 & 0x80) ? 1 : 0;//	value |= (WORD) (((g_psGpio->Gpdat0>>7) & 0x1 )<<5);	value |= (WORD) (((g_psGpio->Gpdat0) & 0x80 )>>2);	while ((g_psGpio->Agpdat & 0x1) == 1);		while ((g_psGpio->Agpdat & 0x1) == 0);//	i2sData.bit_item.bBit4 = (g_psGpio->Gpdat0 & 0x80) ? 1 : 0;//	value |= (WORD) (((g_psGpio->Gpdat0>>7) & 0x1 )<<4);	value |= (WORD) (((g_psGpio->Gpdat0) & 0x80 )>>3);	while ((g_psGpio->Agpdat & 0x1) == 1);		while ((g_psGpio->Agpdat & 0x1) == 0);//	i2sData.bit_item.bBit3 = (g_psGpio->Gpdat0 & 0x80) ? 1 : 0;//	value |= (WORD) (((g_psGpio->Gpdat0>>7) & 0x1 )<<3);	value |= (WORD) (((g_psGpio->Gpdat0) & 0x80 )>>4);	while ((g_psGpio->Agpdat & 0x1) == 1);		while ((g_psGpio->Agpdat & 0x1) == 0);//	i2sData.bit_item.bBit2 = (g_psGpio->Gpdat0 & 0x80) ? 1 : 0;//	value |= (WORD) (((g_psGpio->Gpdat0>>7) & 0x1 )<<2);	value |= (WORD) (((g_psGpio->Gpdat0) & 0x80 )>>5);	while ((g_psGpio->Agpdat & 0x1) == 1);		while ((g_psGpio->Agpdat & 0x1) == 0);//	i2sData.bit_item.bBit1 = (g_psGpio->Gpdat0 & 0x80) ? 1 : 0;//	value |= (WORD) (((g_psGpio->Gpdat0>>7) & 0x1 )<<1);	value |= (WORD) (((g_psGpio->Gpdat0) & 0x80 )>>6);	while ((g_psGpio->Agpdat & 0x1) == 1);		while ((g_psGpio->Agpdat & 0x1) == 0);//	i2sData.bit_item.bBit0 = (g_psGpio->Gpdat0 & 0x80) ? 1 : 0;//	value |= (WORD) (((g_psGpio->Gpdat0>>7) & 0x1 ));	value |= (WORD) (((g_psGpio->Gpdat0) & 0x80 )>>7);	//	audio_record_buf[current_num_dma].buf[buf_pos] =(BYTE)(i2sData.wordData >>8);//	audio_record_buf[current_num_dma].buf[buf_pos] =(BYTE)((value)>>8);	audio_record_buf1[current_num_dma]->buf[buf_pos] =(BYTE)((value)>>8);	buf_pos++;//	audio_record_buf[current_num_dma].buf[buf_pos] =(BYTE) (i2sData.wordData & 0xFF);	audio_record_buf1[current_num_dma]->buf[buf_pos] = (BYTE) (value & 0xFF);	buf_pos++;		if (buf_pos>=buf_size)	{		#if SOFT_RECORD    	EventSet(SOFT_RECORD_AUDIO, EVENT_WAVE_IN_DATA);		#endif		current_num_dma++;		if (current_num_dma == buf_num)			current_num_dma = 0;		buf_pos=0;			}	regTimerPtr->TmC &= ~BIT0;	regTimerPtr->Tpc &= 0xFFFF0000;	regTimerPtr->TmV = 0;	isr->MiMask |= IM_TM3;	regTimerPtr->TmC |= BIT0;	return; 				#endif}//Parameter 1: sample rate :Support 8Khz 16Khz//Parameter 2: channel number//Parameter 3: sample size : 1 bytes or 2 bytes //Parameter 4: callbackfunction//Parameter 5: buffer len by user. If using task, max buffer len is 2048. Otherwise max buffer len is 1024//Parameter 6: Using Task or not 1: use task 0: not use task.//Note: if sample size == 2, buf_size should be set 2048. if sample size == 1, buf_size should be set 1024SBYTE Audio_OpenInputDevice(WORD srate, BYTE channels, BYTE sampleSize,DWORD (*AudioRecordCallBack_function)(BYTE *record_buf,DWORD buf_len, BYTE hci_size),DWORD buf_len,BYTE task_enable){	int i=0;	static int isDone = 0;#if (AUDIO_ON == 1) //reset audio internal unit to default settings	BIU       *biu;	biu = (BIU *) (BIU_BASE);	biu->BiuArst &= 0xfffffdff;	biu->BiuArst |= 0x00000200;#endif#if ( (AUDIO_ON == 1) && (AUDIO_DAC == DAC_ES7240) )	Gpio_Config2GpioFunc(GPIO_GPIO_13, GPIO_OUTPUT_MODE, GPIO_DATA_LOW, 1);//set RESETb to low, for DAC_ES7240	MP_DEBUG("DAC_ES7240 RESETB: LOW");#endif#if ( (AUDIO_ON == 1) && (AUDIO_DAC == DAC_WM8904) ) //FGPIO11 is set to run WM8904_InitRecordMode(); by eddy 2012.04.18	//AIU_I2S_AUDIO_INTERFACE();mpDebugPrint("WaveInputStart AIU_I2S_AUDIO_INTERFACE");	Gpio_Config2GpioFunc(GPIO_FGPIO_10, GPIO_INPUT_MODE, GPIO_DATA_LOW, 1);//to set FGPIO11 must set FGPIO10	Gpio_Config2GpioFunc(GPIO_FGPIO_11, GPIO_INPUT_MODE, GPIO_DATA_LOW, 1);//set FGPIO11 to LOW, for DAC_WM8904	mpDebugPrint("Record mode: WM8904 set GPIO_FGPIO_11: GPIO_INPUT_MODE, GPIO_DATA_LOW");#endif	MX6xx_AudioHW_On();	/* Configure audio device */	MP_DEBUG("srate %d, channels %d, samplesize %d",srate, channels, sampleSize<<3);	MX6xx_AudioConfig(srate, channels, sampleSize<<3);	if (AudioRecordCallBack_function != NULL)	audiorecord_CallBackFunction = AudioRecordCallBack_function;	TASK_ENABLE =task_enable;	for (i=0;i<buf_num;i++)	{		//audio_record_buf[i].status = 0x1;		audio_record_buf1[i]=(AUDIO_RECORD_BUF*)mem_malloc(sizeof(AUDIO_RECORD_BUF));		audio_record_buf1[i]->status = 0x1;	}	current_num_dma = 0;	if (!TASK_ENABLE)	{		if (sampleSize == 1)		{			if (buf_len<=1024)				buf_size = buf_len;			else			{				buf_size = 1024;				MP_ALERT("--W-- Max buffer length = 1024");			}		}		else if (sampleSize == 2)		{						if (buf_len<=2048)				buf_size = buf_len;			else			{				buf_size = 2048;				MP_ALERT("--W-- Max buffer length = 2048");			}					}		else		{			MP_ALERT("--E-- The samplesize does not equal to 1 or 2");			return FAIL;		}		AiuDmaRegCallBackFunc(SimAudioISR2);		DmaIntEna(IM_AIUDM);	}	else	{#if RECORD_AUDIO    	if (isDone == 0)    	{     		TaskCreate (RECORD_AUDIO_TASK, WaveInputProc, CONTROL_PRIORITY, 0x4000);			TaskStartup(RECORD_AUDIO_TASK);			#if SOFT_RECORD			EventCreate(SOFT_RECORD_AUDIO, (OS_ATTR_FIFO|OS_ATTR_WAIT_MULTIPLE|OS_ATTR_EVENT_CLEAR), 0);			#endif			#if AMR_RECORD			EventCreate(AMR_RECORD_AUDIO, (OS_ATTR_FIFO|OS_ATTR_WAIT_MULTIPLE|OS_ATTR_EVENT_CLEAR), 0);			#endif			write_magic_number = 0;        	isDone = 1;    	}		#if SOFT_RECORD		TimerInit(3,90,Timercallbackfunction);		#endif	#endif		if (buf_len<=2048)			buf_size = buf_len;		else		{			buf_size = 2048;			MP_ALERT("Max buffer length = 2048");		}		#if AMR_RECORD		EventSet(AMR_RECORD_AUDIO,BIT0);		#endif		soft_irq = 0;	}	return PASS;}SBYTE WaveInputStart(){	MP_DEBUG("WaveInputStart");	BYTE *bbb = (BYTE *)((DWORD)audio_record_buf1[0]->buf | 0xa0000000);	AIU_PLAYBACK_GAI_DISABLE();	AIU_RECORD_GAI_ENABLE();	#if ( (AUDIO_ON == 1) && (AUDIO_DAC == DAC_ES7240) )	AIU_I2S_AUDIO_INTERFACE();mpDebugPrint("WaveInputStart AIU_I2S_AUDIO_INTERFACE");#endif	MP_DEBUG("g_psAiu->AiuCtl 0x%.8x",g_psAiu->AiuCtl);	MP_DEBUG("g_psAiu->AiuCtl1 0x%.8x",g_psAiu->AiuCtl1);	MX6xx_AudioSetVolume(g_bVolumeIndex);	#if ( (AUDIO_ON == 1) && (AUDIO_DAC == DAC_ES7240) )	Gpio_Config2GpioFunc(GPIO_GPIO_13, GPIO_OUTPUT_MODE, GPIO_DATA_HIGH, 1);//set RESETb to high, for DAC_ES7240	MP_DEBUG("DAC_ES7240 RESETB: HIGH");#endif	PCMRecordStart1(bbb, buf_size);	}SBYTE WaveInputEnd(){	register CHANNEL *audio_dma;	audio_dma = (CHANNEL *) (DMA_AIU_BASE);	audio_dma->Control &= ~0x00000001;}// When Bt aiudio dis-connect success shall de-initilize audio output moduleSBYTE Audio_CloseInputDevice(){	int i=0;	if (TASK_ENABLE)	{		#if !SOFT_RECORD				while(still_record)				TaskYield();		#endif			#if RECORD_AUDIO				#if SOFT_RECORD				TimerDeInit(3);			#endif		#endif		soft_irq = 1;		#if !SOFT_RECORD			MX6xx_AudioPause();			MX6xx_AudioClose();					#endif			}	write_magic_number = 1;	#if ( (AUDIO_ON == 1) && (AUDIO_DAC == DAC_WM8904) ) //FGPIO11 is set to run WM8904_InitRecordMode(); by eddy 2012.04.18		//AIU_RIGHT_JUSTIFIED();mpDebugPrint("Audio_CloseInputDevice AIU_RIGHT_JUSTIFIED");		Gpio_Config2GpioFunc(GPIO_FGPIO_10, GPIO_OUTPUT_MODE, GPIO_DATA_HIGH, 1);//to set FGPIO11 must set FGPIO10		Gpio_Config2GpioFunc(GPIO_FGPIO_11, GPIO_OUTPUT_MODE, GPIO_DATA_HIGH, 1);//set FGPIO11 to LOW, for DAC_WM8904		MP_DEBUG("Play mode: WM8904 set GPIO_FGPIO_11: GPIO_OUTPUT_MODE, GPIO_DATA_HIGH");	#endif		MX6xx_AudioHW_Off();	audiorecord_CallBackFunction = NULL;	for (i = 0;i<buf_num;i++)		mem_free(audio_record_buf1[i]);	return 0;}#if SOFT_RECORDstatic SDWORD WaveInputWaitEvent(DWORD * pdwEvent, DWORD dwNextEvent){    SDWORD ret;    if (dwNextEvent)    {        *pdwEvent = dwNextEvent;        ret = OS_STATUS_OK;    }    else    {        ret = EventWait(SOFT_RECORD_AUDIO, 0x7fffffff, OS_EVENT_OR, pdwEvent);    }    return ret;}SBYTE WaveInputProc(){	mpDebugPrint("WaveInputProc");    DWORD dwEvent, dwNextEvent;	Gpio_Config2GpioFunc(GPIO_GPIO_7, GPIO_INPUT_MODE, 1, 1);	Gpio_Config2GpioFunc(GPIO_GPIO_3, GPIO_OUTPUT_MODE, 1, 1);	MX6xx_AudioSetVolume(g_bVolumeIndex);	while(1)	{		if (WaveInputWaitEvent(&dwEvent, dwNextEvent) == OS_STATUS_OK)		{            if (dwEvent & EVENT_WAVE_IN_DATA)            {    			SBYTE current_num_callback=current_num_dma-1;    			if (current_num_callback<0)    				current_num_callback = 19;    			BYTE *aaa = (BYTE *)((DWORD)audio_record_buf1[current_num_callback]->buf | 0xa0000000);    			//Callback function     			//mpDebugPrint("current_num_callback %d",current_num_callback);    			audiorecord_CallBackFunction(aaa,buf_size,hci_len);            }            TaskYield();		}	}}#elseSBYTE WaveInputProc(){	static int value,call_callback=0,outsize=0;	static BYTE buf_amr[1024],first_done,*bbbptr,*buf_amrptr;	DWORD release;	buf_amrptr = &buf_amr[0];	#if AMR_ENCODE_ENABLE	MagicPixel_AMRENC_Init_All();	#endif	//First Record audio data. // 2010/11/10 xianwen note it.	AIU_PLAYBACK_GAI_DISABLE();	AIU_RECORD_GAI_ENABLE();	AIU_SET_BIGENDIAN();	MX6xx_AudioSetVolume(g_bVolumeIndex);		BYTE *ccc = (BYTE *)((DWORD)audio_record_buf1[current_num_dma]->buf | 0xa0000000);	PCMRecordStart1(ccc, buf_size);	//Check DMA END	while ((g_psDmaAiu->Control & 0x00010000) == 0x00)	{		still_record = 1;		TaskYield();	}	first_done = 1;	call_callback = 0;	while(1)	{		AIU_PLAYBACK_GAI_DISABLE();		AIU_RECORD_GAI_ENABLE();		#if AMR_RECORD		AIU_SET_LITTLEENDIAN();		#else		AIU_SET_BIGENDIAN();		#endif		BYTE *aaa = (BYTE *)((DWORD)audio_record_buf1[current_num_dma]->buf | 0xa0000000);		PCMRecordStart1(aaa, buf_size);		//Check DMA END		while ((g_psDmaAiu->Control & 0x00010000) == 0x00)		{			still_record = 1;			if (!call_callback)			{				if (first_done)				{					#if AMR_ENCODE_ENABLE					outsize = amrChunkEncode((WORD *)ccc,buf_amrptr,buf_size,NULL);					#endif					//outsize = buf_size;					if (audiorecord_CallBackFunction != NULL)					{						audiorecord_CallBackFunction(AMR_MAGIC_NUMBER,strlen(AMR_MAGIC_NUMBER),hci_len);						audiorecord_CallBackFunction(buf_amrptr,outsize,hci_len);					}					first_done = 0;				}				else				{					#if AMR_ENCODE_ENABLE					outsize = amrChunkEncode((WORD *)bbbptr,buf_amrptr,buf_size,NULL);					#endif					//outsize = buf_size;					if (audiorecord_CallBackFunction != NULL)						audiorecord_CallBackFunction(buf_amrptr,outsize,hci_len);									}				call_callback = 1;			}			TaskYield();		}		TaskYield();		call_callback = 0;		still_record = 0;		if (soft_irq || write_magic_number)		{			//mpDebugPrint("WaveInputProc 1-0");			//EventClear(AMR_RECORD_AUDIO, ~BIT0);			#if AMR_RECORD			EventWait(AMR_RECORD_AUDIO, BIT0, OS_EVENT_OR, &release);			#endif			//mpDebugPrint("WaveInputProc 1");			if (audiorecord_CallBackFunction != NULL)			{								audiorecord_CallBackFunction(AMR_MAGIC_NUMBER,strlen(AMR_MAGIC_NUMBER),hci_len);			}			write_magic_number = 0;		}		current_num_dma++;		current_num_dma %=buf_num;			AIU_PLAYBACK_GAI_DISABLE();		AIU_RECORD_GAI_ENABLE();		#if AMR_RECORD		AIU_SET_LITTLEENDIAN();		#else		AIU_SET_BIGENDIAN();		#endif		BYTE *bbb = (BYTE *)((DWORD)audio_record_buf1[current_num_dma]->buf | 0xa0000000);		value = SystemGetTimeStamp();		PCMRecordStart1(bbb, buf_size);		//********************************************************				while ((g_psDmaAiu->Control & 0x00010000) == 0x00)		{			still_record = 1;			if (!call_callback)			{				#if AMR_ENCODE_ENABLE				outsize = amrChunkEncode((WORD *)aaa,buf_amrptr,buf_size,NULL);				#endif				//outsize = buf_size;				if (audiorecord_CallBackFunction != NULL)					audiorecord_CallBackFunction(buf_amrptr,outsize,hci_len);				call_callback = 1;			}						TaskYield();		}		bbbptr = bbb;		call_callback = 0;		still_record = 0;		//********************************************************				current_num_dma++;		current_num_dma %=buf_num;		//if (current_num_dma == buf_num)			//current_num_dma = 0;		TaskYield();		if (soft_irq || write_magic_number)		{			//mpDebugPrint("WaveInputProc 2-0");			//EventClear(AMR_RECORD_AUDIO, ~BIT0);			#if AMR_RECORD			EventWait(AMR_RECORD_AUDIO, BIT0, OS_EVENT_OR, &release);			#endif			//mpDebugPrint("WaveInputProc 2");			if (audiorecord_CallBackFunction != NULL)			{									audiorecord_CallBackFunction(AMR_MAGIC_NUMBER,strlen(AMR_MAGIC_NUMBER),hci_len);			}			write_magic_number = 0;		}	}}#endif// When receive pcm data from usb, pass data to audio by call WaveoutProc  SBYTE WaveOutProc(BYTE* buf,DWORD len){	g_psDmaAiu->Control |= 0x01000000;	DmaIntEna(IM_AIUDM);	g_psDmaAiu->StartA = (DWORD)buf;	g_psDmaAiu->EndA = g_psDmaAiu->StartA + len - 1;	AIU_RECORD_GAI_DISABLE();	AIU_PLAYBACK_GAI_ENABLE();	MX6xx_AudioResume();	return PASS;}SBYTE WaveOutProc_Stream(BYTE* buf,DWORD len){#if ISR_WAVEOUT_STREAM	static DWORD total_len=0;	static BYTE bufferA=0;	//mpDebugPrint("current_playback %d current_receive %d",current_playback,current_receive);	if (len > 2048)	{		UartOutText("buffer is too large, please try to use less than 2048");		return FAIL;	}	//if (audio_playback_buf[current_receive].status != 0x3||( current_playback>current_receive &&current_playback-current_receive<4))	if (audio_playback_buf[current_receive]->status != STATUS_BUFFER_IDLE) //If the quality is bad, try to use the below.		return FAIL;	if (!bufferA)	{		{			mmcp_memcpy(&audio_playback_buf[current_receive]->buf[0],buf,len);			audio_playback_buf[current_receive]->len = len;			if (first)			{				g_psDmaAiu->StartA = (DWORD)(&audio_playback_buf[current_receive]->buf);				g_psDmaAiu->EndA = g_psDmaAiu->StartA + len - 1;			}			audio_playback_buf[current_receive]->status = STATUS_BUFFER_WORKING;			bufferA = 1;			current_receive++;		}	}	else	{		{			mmcp_memcpy(&audio_playback_buf[current_receive]->buf[0],buf,len);				audio_playback_buf[current_receive]->len = len;			if (first)			{				g_psDmaAiu->Control |= 0x01000000;				DmaIntEna(IM_AIUDM);							g_psDmaAiu->StartB = (DWORD)(&audio_playback_buf[current_receive]->buf);				g_psDmaAiu->EndB = g_psDmaAiu->StartB + len - 1;			}			audio_playback_buf[current_receive]->status = STATUS_BUFFER_WORKING;			bufferA = 0;			if (first)			{				AIU_RECORD_GAI_DISABLE();				AIU_PLAYBACK_GAI_ENABLE();							MX6xx_AudioResume();					first =0;			}			current_receive++;		}			}	if (current_receive >= buf_num_playback)		current_receive = 0;		return PASS;#else	return PASS;#endif}// Process can check if wave buffer is played by calling this function// Return value -//  0 : Audio buffer is played// -1 : ErrorSBYTE WaveOutWriteDone(){	// Send mail...?	SBYTE ret = -1;	IntDisable();	if(bufferEnd > 0){		ret = 0;		bufferEnd--;	}	IntEnable();	return ret;}void SimAudioISR(){	g_psDmaAiu->Control &= ~0x00010000;	/* clear buffer end interrupt */#if ISR_WAVEOUT_STREAM		audio_playback_buf[current_playback]->status = STATUS_BUFFER_IDLE;		current_playback++;		if (current_playback >=buf_num_playback)			current_playback = 0;		if (g_psDmaAiu->Control & 0x8000)		{	//we treat this as buffer A playback completed			g_psDmaAiu->StartA = (DWORD)(&audio_playback_buf[current_playback]->buf);			g_psDmaAiu->EndA = g_psDmaAiu->StartA + audio_playback_buf[current_playback]->len - 1;		}		else		{	//we treat this as buffer B playback completed			g_psDmaAiu->StartB = (DWORD)(&audio_playback_buf[current_playback]->buf);			g_psDmaAiu->EndB = g_psDmaAiu->StartB + audio_playback_buf[current_playback]->len - 1;		}#else		MX6xx_AudioPause();		bufferEnd += 1;#endif		}//int ccount,a=0;// to count the time spent after 8 times//DWORD starttime;// to count the time spent after 8 timesvoid SimAudioISR2(){	static int jj =0;	static int ii =0;	if (ii>=1024)		ii =0;	g_psDmaAiu->Control &= ~0x00010000;	/* clear buffer end interrupt */	BYTE *bbb = (BYTE *)((DWORD)audio_record_buf1[current_num_dma]->buf | 0xa0000000);	MP_DEBUG("@ audio_buf[%d,%d]=%x, %x",ii,ii+1,*(bbb+ii),*(bbb+ii+1));#if 0	// count the time spent after 8 times	if(a==0) 		{		starttime=GetSysTime();		a=1;ccount=0;		}	else		{		ccount++;		}	if (ccount>=8)		{		mpDebugPrint("(buf_size %d)*%d; time:%d",buf_size,ccount,SystemGetElapsedTime(starttime));		a=0;		}#endif#if 0//( (AUDIO_ON == 1) && (AUDIO_DAC == DAC_ES7240) ) //divide the sample by 2 to decrease the amplitude of recorded sample	SBYTE sample;	for(jj=0;jj<buf_size;jj++)		{		sample =(SBYTE) *(bbb+jj);		sample /=2;		*(bbb+jj) = (BYTE)sample;		}	//	MP_DEBUG("# audio_buf[%d,%d]=%x, %x\n",ii,ii+1,*(bbb+ii),*(bbb+ii+1)); //data after dividing the sample by 2#endif	ii+=2;// this is just for debug	audiorecord_CallBackFunction(bbb,buf_size,hci_len);	current_num_dma++;	current_num_dma %= buf_num;	BYTE *aaa = (BYTE *)((DWORD)audio_record_buf1[current_num_dma]->buf | 0xa0000000);			/*if (g_psDmaAiu->Control & 0x8000)	{	//we treat this as buffer A playback completed		g_psDmaAiu->StartA = (DWORD)(aaa);		g_psDmaAiu->EndA = g_psDmaAiu->StartA + buf_size - 1;	}	else	{	//we treat this as buffer B playback completed		g_psDmaAiu->StartB = (DWORD)(aaa);		g_psDmaAiu->EndB = g_psDmaAiu->StartB + buf_size - 1;		}*/	PCMRecordStart1(aaa,buf_size);}static inline void CleanAllBufferState(){	int i=0;	for(i=0;i<buf_num;i++)	{		if (i!=current_num_dma)				audio_record_buf1[current_num_dma]->status = 0x1;	}}static WORD PCMRecordStart1(unsigned char *buffer, DWORD size){	register AIU *aiu;	register CHANNEL *audio_dma;	WORD sampleRate;	aiu = (AIU *) (AIU_BASE);	audio_dma = (CHANNEL *) (DMA_AIU_BASE);	//At this test PCM_0 type song, we need to set Little endian case	//aiu->AiuCtl1 &= 0xBFFFFFFF; /*set "ENDIAN" = 0 as "little endian" AVi  */	// Clear DMA END interrupt	audio_dma->Control = 0;	// set DMA Buffer	audio_dma->StartA = (DWORD) buffer;	audio_dma->EndA = (DWORD) buffer +size - 1;	// DMA enable, BUFFER END interrupt enable	if (!TASK_ENABLE)		audio_dma->Control = 0x01000001;	//audio_dma->Control |=(BIT3 | BIT1);	else		audio_dma->Control = 0x00000001;	return sampleRate;}int DecodeWavHader1(WAV_CONFIG * Config, PCM_DATA_BLOCK * Bufer){	PCM_DATA_BLOCK *WavBufer;	WAV_CONFIG *wavcfg;	BYTE *stream;	DWORD BufferOffset, chunksize, mark;	WORD wdata;	WavBufer = Bufer;	wavcfg = Config;	stream = WavBufer->start;	wavcfg->Channels = 0;	wavcfg->SampleRate = 0;	wavcfg->AvgBytesPerSec = 0;	wavcfg->BlockAlign = 0;	wavcfg->BitsPerSample = 0;	wavcfg->DataOffset = 0;	wavcfg->DataSize = 0;	// check group ID "RIFF"	MGET_DWORD(stream, mark);	if (mark != 0x46464952)		return 1;	// get group size	MGET_DWORD(stream, chunksize);	if (!chunksize)		return 1;	// check riff type "WAVE"	MGET_DWORD(stream, mark);	if (mark != 0x45564157)		return 1;	BufferOffset = 12;	while (WavBufer->size > BufferOffset)	{		MGET_DWORD(stream, mark);		MGET_DWORD(stream, chunksize);		BufferOffset += 8;		switch (mark)		{		case 0x20746D66:		// fmt			MGET_WORD(stream, wdata);	// format Tage			if (wdata != 0x0001)				return 1;		// only support no compress wav file			MGET_WORD(stream, wavcfg->Channels);			MGET_DWORD(stream, wavcfg->SampleRate);			MGET_DWORD(stream, wavcfg->AvgBytesPerSec);			MGET_WORD(stream, wavcfg->BlockAlign);			MGET_WORD(stream, wavcfg->BitsPerSample);			if (wavcfg->BlockAlign != (wavcfg->BitsPerSample >> 3) * (wavcfg->Channels))				return 1;			BufferOffset += chunksize;			break;		case 0x61746164:		// data			wavcfg->DataOffset = BufferOffset;			wavcfg->DataSize = chunksize;			BufferOffset += chunksize;			MGET_SKIPBYTE(stream, chunksize);			break;		default:			BufferOffset += chunksize;			MGET_SKIPBYTE(stream, chunksize);			break;		}	}	/* while */	if (wavcfg->DataSize == 0)		return 1;	if (wavcfg->SampleRate == 0)		return 1;	return 0;}#endif